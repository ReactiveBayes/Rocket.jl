var documenterSearchIndex = {"docs":
[{"location":"operators/utility/skip_complete/#operator_skip_complete","page":"skip_complete","title":"SkipComplete Operator","text":"","category":"section"},{"location":"operators/utility/skip_complete/","page":"skip_complete","title":"skip_complete","text":"skip_complete","category":"page"},{"location":"operators/utility/skip_complete/#Rocket.skip_complete","page":"skip_complete","title":"Rocket.skip_complete","text":"skip_complete()\n\nCreates a skip_complete operator, which filters out complete event by the source Observable by emitting only next and error messages.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> skip_complete(), logger())\n;\n\n# output\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, skip_error, skip_next, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/skip_complete/#See-also","page":"skip_complete","title":"See also","text":"","category":"section"},{"location":"operators/utility/skip_complete/","page":"skip_complete","title":"skip_complete","text":"Operators","category":"page"},{"location":"operators/transformation/start_with/#operator_start_with","page":"start_with","title":"StartWith Operator","text":"","category":"section"},{"location":"operators/transformation/start_with/","page":"start_with","title":"start_with","text":"start_with","category":"page"},{"location":"operators/transformation/start_with/#Rocket.start_with","page":"start_with","title":"Rocket.start_with","text":"start_with(object::O) where O\n\nCreates a start_with operator, which forces an observable to emit given object as a first value.\n\nProducing\n\nStream of type <: Subscribable{Union{L, O}} where L refers to type of source stream <: Subscribable{L}\n\nExamples\n\nusing Rocket\n\nsource = from(1:3) |> start_with(0)\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/start_with/#See-also","page":"start_with","title":"See also","text":"","category":"section"},{"location":"operators/transformation/start_with/","page":"start_with","title":"start_with","text":"Operators","category":"page"},{"location":"actors/types/server/#actor_server","page":"Server","title":"Server actor","text":"","category":"section"},{"location":"actors/types/server/","page":"Server","title":"Server","text":"server","category":"page"},{"location":"actors/types/server/#Rocket.server","page":"Server","title":"Rocket.server","text":"server(port::Int)\nserver(address::A, port::Int) where { A <: IPAddr }\nserver(::Type{D}, port::Int)\nserver(::Type{D}, address::A, port::Int) where { A <: IPAddr }\n\nCreation operator for the ServerActor actor.\n\nSee also: AbstractActor\n\n\n\n\n\n","category":"function"},{"location":"actors/types/server/","page":"Server","title":"Server","text":"ServerActor","category":"page"},{"location":"actors/types/server/#Rocket.ServerActor","page":"Server","title":"Rocket.ServerActor","text":"ServerActor{D, Address, Port}() where D\n\nThe ServerActor sends all next!/error!/complete! events to the local network listeners with specified Address and Port parameters via TCPSocket.\n\nSee also: Actor, server\n\n\n\n\n\n","category":"type"},{"location":"operators/transformation/exhaust_map/#operator_exhaust_map","page":"exhaust_map","title":"ExhaustMap Operator","text":"","category":"section"},{"location":"operators/transformation/exhaust_map/","page":"exhaust_map","title":"exhaust_map","text":"exhaust_map","category":"page"},{"location":"operators/transformation/exhaust_map/#Rocket.exhaust_map","page":"exhaust_map","title":"Rocket.exhaust_map","text":"exhaust_map(::Type{R}, mappingFn::F = identity) where { R, F <: Function }\n\nCreates a exhaust_map operator, which returns an Observable containing projected Observables of each item of the source, ignoring projected Observables that start before their preceding Observable has completed. Essentially it projects each source value to an Observable which is merged in the output Observable only if the previous projected Observable has completed.\n\nArguments\n\n::Type{R}: the type of data of output Observables after projection with mappingFn\nmappingFn::F: projection function with (data) -> Observable{R} signature\n\nProducing\n\nStream of type <: Subscribable{R}\n\nExamples\n\nusing Rocket\n\nsource = from([ 0, 0 ]) |> async() |> exhaust_map(Int, d -> from([ 1, 2 ]) |> async())\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Completed\n\nSee also: AbstractOperator, RightTypedOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/exhaust_map/#See-also","page":"exhaust_map","title":"See also","text":"","category":"section"},{"location":"operators/transformation/exhaust_map/","page":"exhaust_map","title":"exhaust_map","text":"Operators","category":"page"},{"location":"operators/utility/ref_count/#operator_ref_count","page":"ref_count","title":"Ref Count Operator","text":"","category":"section"},{"location":"operators/utility/ref_count/","page":"ref_count","title":"ref_count","text":"ref_count","category":"page"},{"location":"operators/utility/ref_count/#Rocket.ref_count","page":"ref_count","title":"Rocket.ref_count","text":"ref_count()\n\nMake a ConnectableObservable behave like a ordinary observable and automates the way you can connect to it. Internally it counts the subscriptions to the observable and subscribes (only once) to the source if the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it unsubscribes from the source. This way you can make sure that everything before the published refCount has only a single subscription independently of the number of subscribers to the target observable.\n\nNote that using the share operator is exactly the same as using the publish operator (making the observable hot) and the ref_count() operator in a sequence.\n\nExample\n\nusing Rocket\n\nsubject = Subject(Int, scheduler = AsapScheduler())\nsource  = from(1:5) |> multicast(subject) |> ref_count()\n\nactor1 = logger(\"1\")\nactor2 = logger(\"2\")\n\nsubscription1 = subscribe!(source, actor1)\nsubscription2 = subscribe!(source, actor2)\n\nunsubscribe!(subscription1)\nunsubscribe!(subscription2)\n;\n\n# output\n[1] Data: 1\n[1] Data: 2\n[1] Data: 3\n[1] Data: 4\n[1] Data: 5\n[1] Completed\n[2] Completed\n\nSee also: AbstractOperator, publish, multicast, share\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/ref_count/#See-also","page":"ref_count","title":"See also","text":"","category":"section"},{"location":"operators/utility/ref_count/","page":"ref_count","title":"ref_count","text":"Operators","category":"page"},{"location":"actors/types/keep/#actor_keep","page":"Keep","title":"Keep actor","text":"","category":"section"},{"location":"actors/types/keep/","page":"Keep","title":"Keep","text":"keep","category":"page"},{"location":"actors/types/keep/#Rocket.keep","page":"Keep","title":"Rocket.keep","text":"keep(::Type{T}) where T\n\nArguments\n\n::Type{T}: Type of keep data\n\nCreation operator for the KeepActor actor.\n\nExamples\n\nusing Rocket\n\nactor = keep(Int)\nactor isa KeepActor{Int}\n\n# output\ntrue\n\nSee also: KeepActor, AbstractActor\n\n\n\n\n\n","category":"function"},{"location":"actors/types/keep/","page":"Keep","title":"Keep","text":"KeepActor","category":"page"},{"location":"actors/types/keep/#Rocket.KeepActor","page":"Keep","title":"Rocket.KeepActor","text":"KeepActor{D}() where D\n\nKeep actor provides a storage actor. It saves all incoming successful next events in a values array, throws an ErrorException on error! event and does nothing on completion event.\n\nExamples\n\nusing Rocket\n\nsource = from(1:5)\nactor  = keep(Int)\n\nsubscribe!(source, actor)\nshow(getvalues(actor))\n\n# output\n[1, 2, 3, 4, 5]\n\nSee also: Actor, keep\n\n\n\n\n\n","category":"type"},{"location":"observables/types/collected/#observable_collected","page":"Collected","title":"Collected Observable","text":"","category":"section"},{"location":"observables/types/collected/","page":"Collected","title":"Collected","text":"collectLatest","category":"page"},{"location":"observables/types/collected/#Rocket.collectLatest","page":"Collected","title":"Rocket.collectLatest","text":"collectLatest(sources::S, mappingFn::F = copy) where { S, F }\ncollectLatest(::Type{T}, ::Type{R}, sources::S, mappingFn::F = copy)\n\nCollects values from multible Observables and emits it in one single array every time each inner Observable has a new value. Reemits errors from inner observables. Completes when all inner observables completes.\n\nArguments\n\nsources: input sources\nmappingFn: optional mappingFn applied to an array of emited values, copy by default, should return a Vector\n\nNote: collectLatest completes immediately if sources are empty.\n\nOptional arguments\n\n::Type{T}: optional type of emmiting values of inner observables\n::Type{R}: optional return type after applying mappingFn to a vector of values\n\nExamples\n\nusing Rocket\n\ncollected = collectLatest([ of(1), from([ 1, 2 ]) ])\n\nsubscribe!(collected, logger())\n;\n\n# output\n\n[LogActor] Data: [1, 1]\n[LogActor] Data: [1, 2]\n[LogActor] Completed\n\nSee also: Subscribable, subscribe!, combineLatest\n\n\n\n\n\n","category":"function"},{"location":"observables/types/collected/#Description","page":"Collected","title":"Description","text":"","category":"section"},{"location":"observables/types/collected/","page":"Collected","title":"Collected","text":"collectLatest collects the values from all Observables in its vector argument. This is done by subscribing to each Observable in order and, whenever an Observable emits, collecting a vector of the most recent values from each Observable (in order). If you pass n Observables to collectLatest, the returned Observable will always emit an ordered vector of n values.","category":"page"},{"location":"observables/types/collected/","page":"Collected","title":"Collected","text":"To ensure that the output vector has a consistent length, collectLatest waits for all input Observables to emit at least once before it starts emitting results. This means that if some Observable emits values before other Observables started emitting, all these values but the last will be lost. On the other hand, if some Observable does not emit a value but completes, the resulting Observable will complete simultaneously without emitting anything. Furthermore, if some input Observable does not emit any value and never completes, collectLatest will also never emit and never complete.","category":"page"},{"location":"observables/types/collected/","page":"Collected","title":"Collected","text":"If at least one Observable was passed to collectLatest and all passed Observables emitted, then the resulting Observable will complete when all combined streams complete. So even if some Observable completes, the result of collectLatest will still emit values when the other Observables do. In case of a completed Observable, its value will now remain to be the last emitted value. On the other hand, if any Observable errors, collectLatest will also immediately error.","category":"page"},{"location":"observables/types/defer/#observable_defer","page":"Defer","title":"Defer Observable","text":"","category":"section"},{"location":"observables/types/defer/","page":"Defer","title":"Defer","text":"defer","category":"page"},{"location":"observables/types/defer/#Rocket.defer","page":"Defer","title":"Rocket.defer","text":"defer(::Type{D}, factoryFn::F) where { D, F <: Function }\n\nCreates an Observable that, on subscribe, calls an Observable factory to make an Observable for each new Observer.\n\nArguments\n\nT: type of output data source, created by the factoryFn\nfactoryFn: the Observable factory function to invoke for each Observer that subscribes to the output Observable\n\nExamples\n\nusing Rocket\n\nsource = defer(Int, () -> from([ 1, 2, 3 ]))\n\nsubscribe!(source, logger())\n;\n\n# output\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Completed\n\nSee also: Subscribable, subscribe!, logger\n\n\n\n\n\n","category":"function"},{"location":"observables/types/defer/#Description","page":"Defer","title":"Description","text":"","category":"section"},{"location":"observables/types/defer/","page":"Defer","title":"Defer","text":"defer allows you to create the Observable only when the Actor subscribes, and create a fresh Observable for each Actor. It waits until an Actor subscribes to it, and then it generates an Observable, typically with an Observable factory function. It does this afresh for each subscriber, so although each subscriber may think it is subscribing to the same Observable, in fact each subscriber gets its own individual Observable.","category":"page"},{"location":"operators/filtering/last/#operator_last","page":"last","title":"Last Operator","text":"","category":"section"},{"location":"operators/filtering/last/","page":"last","title":"last","text":"last","category":"page"},{"location":"operators/filtering/last/#Base.last","page":"last","title":"Base.last","text":"last(; default = nothing)\n\nCreates a last operator, which returns an Observable that emits only the last item emitted by the source Observable. Sends LastNotFoundException error message if a given source completes without emitting a single value.\n\nArguments\n\ndefault: an optional default value to provide if no values were emitted\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> last(), logger())\n;\n\n# output\n\n[LogActor] Data: 3\n[LogActor] Completed\n\n\nusing Rocket\n\nsource = from(Int[])\nsubscribe!(source |> last() |> catch_error((err, obs) -> of(1)), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Completed\n\nusing Rocket\n\nsource = from(Int[])\nsubscribe!(source |> last(default = 1), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/filtering/last/#Description","page":"last","title":"Description","text":"","category":"section"},{"location":"operators/filtering/last/","page":"last","title":"last","text":"last operator returns an Observable that emits only the last item emitted by the source Observable.","category":"page"},{"location":"operators/filtering/last/#See-also","page":"last","title":"See also","text":"","category":"section"},{"location":"operators/filtering/last/","page":"last","title":"last","text":"Operators","category":"page"},{"location":"operators/utility/tap_on_subscribe/#operator_tap_on_subscribe","page":"tap_on_subscribe","title":"TapOnSubscribe Operator","text":"","category":"section"},{"location":"operators/utility/tap_on_subscribe/","page":"tap_on_subscribe","title":"tap_on_subscribe","text":"TapBeforeSubscription\nTapAfterSubscription\ntap_on_subscribe","category":"page"},{"location":"operators/utility/tap_on_subscribe/#Rocket.TapBeforeSubscription","page":"tap_on_subscribe","title":"Rocket.TapBeforeSubscription","text":"TapBeforeSubscription\n\nOne of the strategies for tap_on_subscribe operator. With TapBeforeSubscription tap callback will be called before actual subscription.\n\nSee also: tap_on_subscribe, TapAfterSubscription\n\n\n\n\n\n","category":"type"},{"location":"operators/utility/tap_on_subscribe/#Rocket.TapAfterSubscription","page":"tap_on_subscribe","title":"Rocket.TapAfterSubscription","text":"TapAfterSubscription\n\nOne of the strategies for tap_on_subscribe operator. With TapBeforeSubscription tap callback will be called after actual subscription.\n\nSee also: tap_on_subscribe, TapBeforeSubscription\n\n\n\n\n\n","category":"type"},{"location":"operators/utility/tap_on_subscribe/#Rocket.tap_on_subscribe","page":"tap_on_subscribe","title":"Rocket.tap_on_subscribe","text":"tap_on_subscribe(tapFn::F, strategy::S = TapBeforeSubscription()) where { F <: Function }\n\nCreates a tap operator, which performs a side effect on the subscription on the source Observable, but return an Observable that is identical to the source.\n\nArguments\n\ntapFn::Function: side-effect tap function with () -> Nothing signature\nstrategy: (optional), specifies the order of a side-effect and an actual subscription, uses TapBeforeSubscription by default\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> tap_on_subscribe(() -> println(\"Someone subscribed\")), logger())\n;\n\n# output\n\nSomeone subscribed\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Completed\n\nusing Rocket\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> tap_on_subscribe(() -> println(\"Someone subscribed\"), TapAfterSubscription()), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Completed\nSomeone subscribed\n\nSee also: TapBeforeSubscription, TapAfterSubscription, tap, tap_on_unsubscribe, tap_on_complete, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/tap_on_subscribe/#Description","page":"tap_on_subscribe","title":"Description","text":"","category":"section"},{"location":"operators/utility/tap_on_subscribe/","page":"tap_on_subscribe","title":"tap_on_subscribe","text":"Returns an Observable that resembles the source Observable, but modifies it so that the provided Observer is called to perform a side effect on subscription to the source.","category":"page"},{"location":"operators/utility/tap_on_subscribe/","page":"tap_on_subscribe","title":"tap_on_subscribe","text":"This operator is useful for debugging your Observables, verifying correctness, or performing other side effects.","category":"page"},{"location":"operators/utility/tap_on_subscribe/","page":"tap_on_subscribe","title":"tap_on_subscribe","text":"Note: this operator differs from a subscribe on the Observable. If the Observable returned by tap_on_subscribe is not subscribed, the side effects specified by the Observer will never happen. tap_on_subscribe therefore simply spies on future execution, it does not trigger an execution to happen like subscribe does.","category":"page"},{"location":"operators/utility/tap_on_subscribe/#See-also","page":"tap_on_subscribe","title":"See also","text":"","category":"section"},{"location":"operators/utility/tap_on_subscribe/","page":"tap_on_subscribe","title":"tap_on_subscribe","text":"Operators","category":"page"},{"location":"operators/utility/safe/#operator_safe","page":"safe","title":"Safe Operator","text":"","category":"section"},{"location":"operators/utility/safe/","page":"safe","title":"safe","text":"safe","category":"page"},{"location":"operators/utility/safe/#Rocket.safe","page":"safe","title":"Rocket.safe","text":"safe()\n\nCreates a SafeOperator, which wraps on_subscribe! and each next!, error! and complete! callbacks into try-catch block.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/safe/#See-also","page":"safe","title":"See also","text":"","category":"section"},{"location":"operators/utility/safe/","page":"safe","title":"safe","text":"Operators","category":"page"},{"location":"operators/utility/skip_next/#operator_skip_next","page":"skip_next","title":"SkipNext Operator","text":"","category":"section"},{"location":"operators/utility/skip_next/","page":"skip_next","title":"skip_next","text":"skip_next","category":"page"},{"location":"operators/utility/skip_next/#Rocket.skip_next","page":"skip_next","title":"Rocket.skip_next","text":"skip_next()\n\nCreates a skip_next operator, which filters out all next messages by the source Observable by emitting only error and complete messages.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> skip_next(), logger())\n;\n\n# output\n[LogActor] Completed\n\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, skip_error, skip_complete, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/skip_next/#See-also","page":"skip_next","title":"See also","text":"","category":"section"},{"location":"operators/utility/skip_next/","page":"skip_next","title":"skip_next","text":"Operators","category":"page"},{"location":"operators/transformation/switch_map/#operator_switch_map","page":"switch_map","title":"SwitchMap Operator","text":"","category":"section"},{"location":"operators/transformation/switch_map/","page":"switch_map","title":"switch_map","text":"switch_map","category":"page"},{"location":"operators/transformation/switch_map/#Rocket.switch_map","page":"switch_map","title":"Rocket.switch_map","text":"switch_map(::Type{R}, mappingFn::F = identity) where { R, F <: Function }\n\nCreates a switch_map operator, which returns an Observable that emits items based on applying a function mappingFn that you supply to each item emitted by the source Observable, where that function returns an (so-called \"inner\") Observable. Each time it observes one of these inner Observables, the output Observable begins emitting the items emitted by that inner Observable. When a new inner Observable is emitted, switch_map stops emitting items from the earlier-emitted inner Observable and begins emitting items from the new one. It continues to behave like this for subsequent inner Observables.\n\nArguments\n\n::Type{R}: the type of data of output Observables after projection with mappingFn\nmappingFn::F: projection function with (data) -> Observable{R} signature\n\nProducing\n\nStream of type <: Subscribable{R}\n\nExamples\n\nusing Rocket\n\nsource = from([ of(1), of(2), of(3) ])\nsubscribe!(source |> switch_map(Int), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Completed\n\nusing Rocket\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> switch_map(Float64, (d) -> of(convert(Float64, d ^ 2))), logger())\n;\n\n# output\n\n[LogActor] Data: 1.0\n[LogActor] Data: 4.0\n[LogActor] Data: 9.0\n[LogActor] Completed\n\nSee also: AbstractOperator, RightTypedOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/switch_map/#See-also","page":"switch_map","title":"See also","text":"","category":"section"},{"location":"operators/transformation/switch_map/","page":"switch_map","title":"switch_map","text":"Operators","category":"page"},{"location":"api/actors/#actors_api","page":"Actors","title":"Actors API","text":"","category":"section"},{"location":"api/actors/#How-to-create-a-custom-Actor","page":"Actors","title":"How to create a custom Actor","text":"","category":"section"},{"location":"api/actors/","page":"Actors","title":"Actors","text":"At first custom actor should implement a custom method for the as_actor function. Rocket.jl also provides a number of helper actor abstract types with predefined as_actor method behavior (see Traits API section).","category":"page"},{"location":"api/actors/","page":"Actors","title":"Actors","text":"using Rocket\n\nstruct MyCustomActor end\n\nas_actor(::Type{<:MyCustomActor}) = Rocket.BaseActorTrait{Int}()\n","category":"page"},{"location":"api/actors/","page":"Actors","title":"Actors","text":"or","category":"page"},{"location":"api/actors/","page":"Actors","title":"Actors","text":"using Rocket\n\nstruct MyCustomActor <: Actor{Int} end # Automatically specifies BaseActorTrait{Int} behavior.","category":"page"},{"location":"api/actors/","page":"Actors","title":"Actors","text":"Additionally custom actor must provide a custom methods for on_next!, on_error! and/or on_complete! functions. Depending on specified actor trait behavior some methods may or may not be optional.","category":"page"},{"location":"api/actors/","page":"Actors","title":"Actors","text":"using Rocket\n\nstruct MyCustomActor <: Actor{Int} end\n\nRocket.on_next!(actor::MyCustomActor, data::Int)  = # custom logic here\nRocket.on_error!(actor::MyCustomActor, err)       = # custom logic here\nRocket.on_complete!(actor::MyCustomActor)         = # custom logic here","category":"page"},{"location":"api/actors/","page":"Actors","title":"Actors","text":"or","category":"page"},{"location":"api/actors/","page":"Actors","title":"Actors","text":"using Rocket\n\nstruct MyCustomCompletionActor <: CompletionActor{Int} end\n\nRocket.on_complete!(actor::MyCustomCompletionActor) = # custom logic here","category":"page"},{"location":"api/actors/#actors_api_traits","page":"Actors","title":"Traits","text":"","category":"section"},{"location":"api/actors/","page":"Actors","title":"Actors","text":"as_actor\nActorTrait\nBaseActorTrait\nNextActorTrait\nErrorActorTrait\nCompletionActorTrait\nInvalidActorTrait","category":"page"},{"location":"api/actors/#Rocket.as_actor","page":"Actors","title":"Rocket.as_actor","text":"as_actor(any)\n\nThis function checks actor trait behavior specification. May be used explicitly to specify actor trait behavior for any object.\n\nSee also: ActorTrait\n\n\n\n\n\n","category":"function"},{"location":"api/actors/#Rocket.ActorTrait","page":"Actors","title":"Rocket.ActorTrait","text":"Abstract type for all possible actor traits\n\nSee also: BaseActorTrait, NextActorTrait, ErrorActorTrait, CompletionActorTrait, InvalidActorTrait\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Rocket.BaseActorTrait","page":"Actors","title":"Rocket.BaseActorTrait","text":"Base actor trait specifies actor to listen for all next!, error! and complete! events. BaseActorTrait is a subtype of ActorTrait.\n\nSee also: Actor\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Rocket.NextActorTrait","page":"Actors","title":"Rocket.NextActorTrait","text":"Next actor trait specifies actor to listen for next! events only. NextActorTrait is a subtype of ActorTrait.\n\nSee also: NextActor\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Rocket.ErrorActorTrait","page":"Actors","title":"Rocket.ErrorActorTrait","text":"Error actor trait specifies actor to listen for error! events only. ErrorActorTrait is a subtype of ActorTrait.\n\nSee also: ErrorActor\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Rocket.CompletionActorTrait","page":"Actors","title":"Rocket.CompletionActorTrait","text":"Completion actor trait specifies actor to listen for complete! events only. CompletionActorTrait is a subtype of ActorTrait.\n\nSee also: CompletionActor\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Rocket.InvalidActorTrait","page":"Actors","title":"Rocket.InvalidActorTrait","text":"Default actor trait behavior for any object. Actor with such a trait specificaion cannot be used as a valid actor in subscribe! function. Doing so will raise an error. InvalidActorTrait is a subtype of ActorTrait.\n\nSee also: ActorTrait\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Types","page":"Actors","title":"Types","text":"","category":"section"},{"location":"api/actors/","page":"Actors","title":"Actors","text":"AbstractActor\nActor\nNextActor\nErrorActor\nCompletionActor","category":"page"},{"location":"api/actors/#Rocket.AbstractActor","page":"Actors","title":"Rocket.AbstractActor","text":"Supertype type for Actor, NextActor, ErrorActor and CompletionActor types.\n\nSee also: Actor, NextActor, ErrorActor, CompletionActor\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Rocket.Actor","page":"Actors","title":"Rocket.Actor","text":"Can be used as a super type for common actor. Automatically specifies a BaseActorTrait trait behavior. Every Actor must implement its own methods for on_next!(actor, data), on_error!(actor, err) and on_complete!(actor) functions. Actor is a subtype of AbstractActor type.\n\nExamples\n\nusing Rocket\n\nstruct MyActor <: Actor{String} end\n\nRocket.as_actor(MyActor)\n\n# output\n\nBaseActorTrait{String}()\n\nSee also: AbstractActor, as_actor, BaseActorTrait, ActorTrait, on_next!, on_error!, on_complete!\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Rocket.NextActor","page":"Actors","title":"Rocket.NextActor","text":"Can be used as a super type for \"next-only\" actor. Automatically specifies a NextActorTrait trait behavior. Every NextActor must implement its own methods for on_next!(actor, data) function only. NextActor is a subtype of AbstractActor type.\n\nExamples\n\nusing Rocket\n\nstruct MyNextActor <: NextActor{String} end\n\nRocket.as_actor(MyNextActor)\n\n# output\n\nNextActorTrait{String}()\n\nSee also: AbstractActor, as_actor, NextActorTrait, ActorTrait, on_next!\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Rocket.ErrorActor","page":"Actors","title":"Rocket.ErrorActor","text":"Can be used as a super type for \"error-only\" actor. Automatically specifies a ErrorActorTrait trait behavior. Every ErrorActor must implement its own methods for on_error!(actor, err) function only. ErrorActor is a subtype of AbstractActor type.\n\nExamples\n\nusing Rocket\n\nstruct MyErrorActor <: ErrorActor{String} end\n\nRocket.as_actor(MyErrorActor)\n\n# output\n\nErrorActorTrait{String}()\n\nSee also: AbstractActor, as_actor, ErrorActorTrait, ActorTrait, on_error!\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Rocket.CompletionActor","page":"Actors","title":"Rocket.CompletionActor","text":"Can be used as a super type for \"completion-only\" actor. Automatically specifies a CompletionActorTrait trait behavior. Every CompletionActor must implement its own methods for on_complete!(actor) function only. CompletionActor is a subtype of AbstractActor type.\n\nExamples\n\nusing Rocket\n\nstruct MyCompletionActor <: CompletionActor{String} end\n\nRocket.as_actor(MyCompletionActor)\n\n# output\n\nCompletionActorTrait{String}()\n\nSee also: AbstractActor, as_actor, CompletionActorTrait, ActorTrait, on_complete!\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Events","page":"Actors","title":"Events","text":"","category":"section"},{"location":"api/actors/","page":"Actors","title":"Actors","text":"next!\nerror!\ncomplete!","category":"page"},{"location":"api/actors/#Rocket.next!","page":"Actors","title":"Rocket.next!","text":"next!(actor, data)\nnext!(actor, data, scheduler)\n\nThis function is used to deliver a \"next\" event to an actor with some data. Takes optional scheduler object to schedule execution of data delivery.\n\nSee also: AbstractActor, on_next!\n\n\n\n\n\n","category":"function"},{"location":"api/actors/#Rocket.error!","page":"Actors","title":"Rocket.error!","text":"error!(actor, err)\nerror!(actor, err, scheduler)\n\nThis function is used to deliver a \"error\" event to an actor with some err. Takes optional scheduler object to schedule execution of error delivery.\n\nSee also: AbstractActor, on_error!\n\n\n\n\n\n","category":"function"},{"location":"api/actors/#Rocket.complete!","page":"Actors","title":"Rocket.complete!","text":"complete!(actor)\ncomplete!(actor, scheduler)\n\nThis function is used to deliver a \"complete\" event to an actor. Takes optional scheduler object to schedule execution of complete event delivery.\n\nSee also: AbstractActor, on_complete!\n\n\n\n\n\n","category":"function"},{"location":"api/actors/","page":"Actors","title":"Actors","text":"on_next!\non_error!\non_complete!","category":"page"},{"location":"api/actors/#Rocket.on_next!","page":"Actors","title":"Rocket.on_next!","text":"on_next!(actor, data)\n\nBoth Actor and NextActor objects must implement its own method for on_next! function which will be called on \"next\" event.\n\nSee also: Actor, NextActor\n\n\n\n\n\n","category":"function"},{"location":"api/actors/#Rocket.on_error!","page":"Actors","title":"Rocket.on_error!","text":"on_error!(actor, err)\n\nBoth Actor and ErrorActor objects must implement its own method for on_error! function which will be called on \"error\" event.\n\nSee also: Actor, ErrorActor\n\n\n\n\n\n","category":"function"},{"location":"api/actors/#Rocket.on_complete!","page":"Actors","title":"Rocket.on_complete!","text":"on_complete!(actor)\n\nBoth Actor and CompletionActor objects must implement its own method for on_complete! function which will be called on \"complete\" event.\n\nSee also: Actor, CompletionActor\n\n\n\n\n\n","category":"function"},{"location":"api/actors/#Factory","page":"Actors","title":"Factory","text":"","category":"section"},{"location":"api/actors/","page":"Actors","title":"Actors","text":"AbstractActorFactory\ncreate_actor\nMissingCreateActorFactoryImplementationError","category":"page"},{"location":"api/actors/#Rocket.AbstractActorFactory","page":"Actors","title":"Rocket.AbstractActorFactory","text":"Abstract type for all possible actor factories\n\nSee also: Actor\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Rocket.create_actor","page":"Actors","title":"Rocket.create_actor","text":"create_actor(::Type{L}, factory::F) where { L, F <: AbstractActorFactory }\n\nActor creator function for a given factory F. Should be implemented explicitly for any AbstractActorFactory object\n\nSee also: AbstractActorFactory, MissingCreateActorFactoryImplementationError\n\n\n\n\n\n","category":"function"},{"location":"api/actors/#Rocket.MissingCreateActorFactoryImplementationError","page":"Actors","title":"Rocket.MissingCreateActorFactoryImplementationError","text":"This error will be throw if Julia cannot find specific method of 'create_actor()' function for given actor factory\n\nSee also: AbstractActorFactory, create_actor\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Errors","page":"Actors","title":"Errors","text":"","category":"section"},{"location":"api/actors/","page":"Actors","title":"Actors","text":"InvalidActorTraitUsageError\nInconsistentSourceActorDataTypesError\nMissingDataArgumentInNextCall\nMissingErrorArgumentInErrorCall\nExtraArgumentInCompleteCall\nMissingOnNextImplementationError\nMissingOnErrorImplementationError\nMissingOnCompleteImplementationError","category":"page"},{"location":"api/actors/#Rocket.InvalidActorTraitUsageError","page":"Actors","title":"Rocket.InvalidActorTraitUsageError","text":"This error will be thrown if next!, error! or complete! functions are called with invalid actor object\n\nSee also: next!, error!, complete!, InvalidActorTrait\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Rocket.InconsistentSourceActorDataTypesError","page":"Actors","title":"Rocket.InconsistentSourceActorDataTypesError","text":"This error will be thrown if next! function is called with inconsistent data type\n\nSee also: AbstractActor, Subscribable, next!\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Rocket.MissingDataArgumentInNextCall","page":"Actors","title":"Rocket.MissingDataArgumentInNextCall","text":"This error will be thrown if next! function is called without data argument\n\nSee also: next!\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Rocket.MissingErrorArgumentInErrorCall","page":"Actors","title":"Rocket.MissingErrorArgumentInErrorCall","text":"This error will be thrown if error! function is called without err argument\n\nSee also: error!\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Rocket.ExtraArgumentInCompleteCall","page":"Actors","title":"Rocket.ExtraArgumentInCompleteCall","text":"This error will be thrown if complete! function is called with extra data/err argument\n\nSee also: complete!\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Rocket.MissingOnNextImplementationError","page":"Actors","title":"Rocket.MissingOnNextImplementationError","text":"This error will be thrown if Julia cannot find specific method of 'on_next!()' function for given actor and data\n\nSee also: on_next!\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Rocket.MissingOnErrorImplementationError","page":"Actors","title":"Rocket.MissingOnErrorImplementationError","text":"This error will be thrown if Julia cannot find specific method of 'on_error!()' function for given actor\n\nSee also: on_error!\n\n\n\n\n\n","category":"type"},{"location":"api/actors/#Rocket.MissingOnCompleteImplementationError","page":"Actors","title":"Rocket.MissingOnCompleteImplementationError","text":"This error will be thrown if Julia cannot find specific method of 'on_complete!()' function for given actor and data\n\nSee also: on_next!\n\n\n\n\n\n","category":"type"},{"location":"observables/types/array/#observable_array","page":"Array","title":"Array Observable","text":"","category":"section"},{"location":"observables/types/array/","page":"Array","title":"Array","text":"from","category":"page"},{"location":"observables/types/array/#Rocket.from","page":"Array","title":"Rocket.from","text":"from(x; scheduler::H = AsapScheduler()) where { H <: AbstractScheduler }\nfrom(a::Vector{D}; scheduler::H = AsapScheduler()) where { D, H <: AbstractScheduler }\n\nCreation operator for the ArrayObservable that emits either a single value if x has a Scalar trait specification or a collection of values if x has a NonScalar trait specification. Throws an ErrorException if x has UndefinedScalarness trait type. To specify scalarness for arbitrary type T some can implement an additional method for scalarness(::Type{<:MyType}) function and to specify scalarness behavior. Optionally accepts custom scheduler-like object to schedule messages delivery.\n\nArguments\n\nx: an object to be wrapped into array of values\nscheduler: optional, scheduler-like object\n\nFor an object x to be a valid input for a from operator it must implement Rocket.scalarness(::Type{ <: T }) method which should return either Rocket.Scalar or Rocket.NonScalar objects. In first case from operator will treat x as a single scalar value and will wrap it into a vector while in the second case from operator will convert x object into an array using collect function.\n\nFor arbitrary iterable objects consider using iterable creation operator.\n\nNote\n\nfrom operators creates a copy of x using collect on a given object.\n\nExamples\n\nusing Rocket\n\nsource = from([ 0, 1, 2 ])\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Completed\n\n\nusing Rocket\n\nsource = from(( 0, 1, 2 ))\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Completed\n\n\nusing Rocket\n\nsource = from(0)\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Completed\n\n\nusing Rocket\n\nsource = from(\"Hello, world!\")\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: H\n[LogActor] Data: e\n[LogActor] Data: l\n[LogActor] Data: l\n[LogActor] Data: o\n[LogActor] Data: ,\n[LogActor] Data:\n[LogActor] Data: w\n[LogActor] Data: o\n[LogActor] Data: r\n[LogActor] Data: l\n[LogActor] Data: d\n[LogActor] Data: !\n[LogActor] Completed\n\n\nSee also: ArrayObservable, subscribe!, logger, iterable\n\n\n\n\n\n","category":"function"},{"location":"observables/types/array/","page":"Array","title":"Array","text":"ArrayObservable","category":"page"},{"location":"observables/types/array/#Rocket.ArrayObservable","page":"Array","title":"Rocket.ArrayObservable","text":"ArrayObservable{D, H}(values::Vector{D}, scheduler::H) where { D, H }\n\nArrayObservable wraps a regular Julia array into an observable. Uses scheduler object to schedule messages delivery.\n\nConstructor arguments\n\nvalues: array of values to be wrapped\nscheduler: Scheduler-like object\n\nSee also: Subscribable, from\n\n\n\n\n\n","category":"type"},{"location":"api/teardown/#teardown_api","page":"Teardown","title":"Teardown API","text":"","category":"section"},{"location":"api/teardown/","page":"Teardown","title":"Teardown","text":"Any subscription-like object should implement a valid teardown logic.","category":"page"},{"location":"api/teardown/#Example","page":"Teardown","title":"Example","text":"","category":"section"},{"location":"api/teardown/","page":"Teardown","title":"Teardown","text":"using Rocket\n\nstruct MuCustomSubscription <: Teardown\n    # some fields here\nend\n\nRocket.as_teardown(::Type{<:MuCustomSubscription}) = UnsubscribableTeardownLogic()\n\nfunction on_unsubscribe!(subscription::MyCustomSubscription)\n    # dispose resources here\nend","category":"page"},{"location":"api/teardown/#Traits","page":"Teardown","title":"Traits","text":"","category":"section"},{"location":"api/teardown/","page":"Teardown","title":"Teardown","text":"TeardownLogic\nas_teardown\nUnsubscribableTeardownLogic\non_unsubscribe!\nCallableTeardownLogic\nVoidTeardownLogic\nInvalidTeardownLogic","category":"page"},{"location":"api/teardown/#Rocket.TeardownLogic","page":"Teardown","title":"Rocket.TeardownLogic","text":"Abstract type for all possible teardown logic traits.\n\nSee also: UnsubscribableTeardownLogic, CallableTeardownLogic, VoidTeardownLogic, InvalidTeardownLogic\n\n\n\n\n\n","category":"type"},{"location":"api/teardown/#Rocket.as_teardown","page":"Teardown","title":"Rocket.as_teardown","text":"as_teardown(::Type)\n\nThis function checks teardown trait behavior specification. Should be used explicitly to specify teardown logic trait behavior for any object.\n\nExamples\n\nusing Rocket\n\nstruct MySubscription <: Teardown end\n\nRocket.as_teardown(::Type{<:MySubscription}) = UnsubscribableTeardownLogic()\nRocket.on_unsubscribe!(s::MySubscription)    = println(\"Unsubscribed!\")\n\nsubscription = MySubscription()\nunsubscribe!(subscription)\n;\n\n# output\n\nUnsubscribed!\n\nSee also: Teardown, TeardownLogic\n\n\n\n\n\n","category":"function"},{"location":"api/teardown/#Rocket.UnsubscribableTeardownLogic","page":"Teardown","title":"Rocket.UnsubscribableTeardownLogic","text":"Unsubscribable teardown logic trait behavior. Unsubscribable teardown object must define its own method for on_unsubscribe!() function which will be invoked when actor decides to unsubscribe! from Observable.\n\nSee also: TeardownLogic, on_unsubscribe!, unsubscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/teardown/#Rocket.on_unsubscribe!","page":"Teardown","title":"Rocket.on_unsubscribe!","text":"on_unsubscribe!(teardown)\n\nEach valid teardown object with UnsubscribableTeardownLogic trait behavior must implement its own method for on_unsubscribe!() function which will be invoked when actor decides to unsubscribe! from Observable.\n\nSee also: Teardown, TeardownLogic, UnsubscribableTeardownLogic\n\n\n\n\n\n","category":"function"},{"location":"api/teardown/#Rocket.CallableTeardownLogic","page":"Teardown","title":"Rocket.CallableTeardownLogic","text":"Callable teardown logic trait behavior. Callable teardown object must be callable (insert meme with a surprised Pikachu here).\n\nSee also: TeardownLogic, on_unsubscribe!, unsubscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/teardown/#Rocket.VoidTeardownLogic","page":"Teardown","title":"Rocket.VoidTeardownLogic","text":"Void teardown logic trait behavior. Void teardown object does nothing in unsubscribe! and may not define any additional methods.\n\nSee also: TeardownLogic, on_unsubscribe!, unsubscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/teardown/#Rocket.InvalidTeardownLogic","page":"Teardown","title":"Rocket.InvalidTeardownLogic","text":"Default teardown logic trait behavour. Invalid teardwon object cannot be used in unsubscribe! function. Doing so will raise an error.\n\nSee also: TeardownLogic, on_unsubscribe!, unsubscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/teardown/#Types","page":"Teardown","title":"Types","text":"","category":"section"},{"location":"api/teardown/","page":"Teardown","title":"Teardown","text":"Teardown\nunsubscribe!","category":"page"},{"location":"api/teardown/#Rocket.Teardown","page":"Teardown","title":"Rocket.Teardown","text":"Abstract type for any teardown object. Each teardown object must be a subtype of Teardown.\n\nSee also: TeardownLogic\n\n\n\n\n\n","category":"type"},{"location":"api/teardown/#Rocket.unsubscribe!","page":"Teardown","title":"Rocket.unsubscribe!","text":"unsubscribe!(subscription)\nunsubscribe!(subscriptions::Tuple)\nunsubscribe!(subscriptions::AbstractVector)\n\nunsubscribe! function is used to cancel Observable execution and to dispose any kind of resources used during an Observable execution. If the input argument to the unsubscribe! function is either a tuple or a vector, it will first check that all of the arguments are valid subscription objects  and if its true will unsubscribe from each of them individually. \n\nSee also: Teardown, TeardownLogic, on_unsubscribe!\n\n\n\n\n\n","category":"function"},{"location":"api/teardown/#Errors","page":"Teardown","title":"Errors","text":"","category":"section"},{"location":"api/teardown/","page":"Teardown","title":"Teardown","text":"InvalidTeardownLogicTraitUsageError\nInvalidMultipleTeardownLogicTraitUsageError\nMissingOnUnsubscribeImplementationError","category":"page"},{"location":"api/teardown/#Rocket.InvalidTeardownLogicTraitUsageError","page":"Teardown","title":"Rocket.InvalidTeardownLogicTraitUsageError","text":"This error will be thrown if unsubscribe! function is called with invalid teardown object.\n\nSee also: unsubscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/teardown/#Rocket.InvalidMultipleTeardownLogicTraitUsageError","page":"Teardown","title":"Rocket.InvalidMultipleTeardownLogicTraitUsageError","text":"This error will be thrown if unsubscribe! function is called with a tuple with invalid teardown object in it.\n\nSee also: unsubscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/teardown/#Rocket.MissingOnUnsubscribeImplementationError","page":"Teardown","title":"Rocket.MissingOnUnsubscribeImplementationError","text":"This error will be thrown if Julia cannot find specific method of on_unsubscribe!() function for given teardown object.\n\nSee also: on_unsubscribe!\n\n\n\n\n\n","category":"type"},{"location":"operators/transformation/accumulated/#operator_accumulated","page":"accumulated","title":"Accumulated Operator","text":"","category":"section"},{"location":"operators/transformation/accumulated/","page":"accumulated","title":"accumulated","text":"accumulated","category":"page"},{"location":"operators/transformation/accumulated/#Rocket.accumulated","page":"accumulated","title":"Rocket.accumulated","text":"accumulated()\n\nCreates an accumulated operator, which returns an Observable that emits the current item with all of the previous items emitted by the source Observable  in one single ordered array.\n\nProducing\n\nStream of type <: Subscribable{Vector{L}} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> accumulated(), logger())\n;\n\n# output\n\n[LogActor] Data: [1]\n[LogActor] Data: [1, 2]\n[LogActor] Data: [1, 2, 3]\n[LogActor] Completed\n\n\nusing Rocket\n\nsource = of(1)\nsubscribe!(source |> accumulated(), logger())\n;\n\n# output\n\n[LogActor] Data: [1]\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/accumulated/#Description","page":"accumulated","title":"Description","text":"","category":"section"},{"location":"operators/transformation/accumulated/","page":"accumulated","title":"accumulated","text":"Combines all values emitted by the source, using an accumulator function that joins a new source value with the all past values emmited into one single array. This is similar to scan with vcat accumulation function.","category":"page"},{"location":"operators/transformation/accumulated/#See-also","page":"accumulated","title":"See also","text":"","category":"section"},{"location":"operators/transformation/accumulated/","page":"accumulated","title":"accumulated","text":"Operators","category":"page"},{"location":"operators/mathematical/max/#operator_max","page":"max","title":"Max Operator","text":"","category":"section"},{"location":"operators/mathematical/max/","page":"max","title":"max","text":"max","category":"page"},{"location":"operators/mathematical/max/#Base.max","page":"max","title":"Base.max","text":"max(; from = nothing)\n\nCreates a max operator, which emits a single item: the item with the largest value.\n\nArguments\n\nfrom: optional initial maximum value, if nothing first item from the source will be used as initial instead\n\nProducing\n\nStream of type <: Subscribable{Union{L, Nothing}} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource = from([ i for i in 1:42 ])\nsubscribe!(source |> max(), logger())\n;\n\n# output\n\n[LogActor] Data: 42\n[LogActor] Completed\n\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/mathematical/max/#Description","page":"max","title":"Description","text":"","category":"section"},{"location":"operators/mathematical/max/","page":"max","title":"max","text":"The max operator operates on an Observable of similar objects. When the source Observable completes, it emits the item with the largest value.","category":"page"},{"location":"operators/mathematical/max/#See-also","page":"max","title":"See also","text":"","category":"section"},{"location":"operators/mathematical/max/","page":"max","title":"max","text":"Operators","category":"page"},{"location":"operators/errors/catch_error/#operator_catch_error","page":"catch_error","title":"Catch Error Operator","text":"","category":"section"},{"location":"operators/errors/catch_error/","page":"catch_error","title":"catch_error","text":"catch_error","category":"page"},{"location":"operators/errors/catch_error/#Rocket.catch_error","page":"catch_error","title":"Rocket.catch_error","text":"catch_error(selectorFn::F) where F\n\nCreates a CatchErrorOperator, which catches errors on the observable to be handled by returning a new observable or throwing an error.\n\nArguments:\n\nselectorFn::F: a callable object that takes as arguments err, which is the error, and caught, which is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable is returned by the selector will be used to continue the observable chain.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource = from(1:5) |> safe() |> map(Int, (d) -> d == 4 ? error(4) : d) |> catch_error((err, obs) -> of(1))\n\nsubscribe!(source, logger())\n;\n\n# output\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Data: 1\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, rerun, logger, safe\n\n\n\n\n\n","category":"function"},{"location":"operators/errors/catch_error/#See-also","page":"catch_error","title":"See also","text":"","category":"section"},{"location":"operators/errors/catch_error/","page":"catch_error","title":"catch_error","text":"Operators","category":"page"},{"location":"operators/about/#section_operators","page":"Operator","title":"Operators","text":"","category":"section"},{"location":"operators/about/","page":"Operator","title":"Operator","text":"Even though the Observable is the foundation, reactive extensions is mostly useful because of its operators. Operators are the essential pieces that allow complex asynchronous code to be easily composed in a declarative manner.","category":"page"},{"location":"operators/about/#what_are_operators","page":"Operator","title":"What are operators?","text":"","category":"section"},{"location":"operators/about/","page":"Operator","title":"Operator","text":"There are two kinds of operators:","category":"page"},{"location":"operators/about/#Pipeable-operators","page":"Operator","title":"Pipeable operators","text":"","category":"section"},{"location":"operators/about/","page":"Operator","title":"Operator","text":"Pipeable Operators are the kind that can be piped to Observables using the syntax source |> operator(). These include the filter() and map() operators. When called, operators do not change the existing Observable instance. Instead, they return a new Observable, whose subscription logic is based on the first Observable.","category":"page"},{"location":"operators/about/","page":"Operator","title":"Operator","text":"note: Note\nA Pipeable Operator is a function that takes an Observable as its input and returns another Observable. It is a pure operation: the previous Observable remains unmodified.","category":"page"},{"location":"operators/about/","page":"Operator","title":"Operator","text":"A Pipeable Operator is essentially a pure callable object that accepts one Observable as input and returns another Observable as output. Subscribing to the output Observable will also subscribe to the input Observable.","category":"page"},{"location":"operators/about/","page":"Operator","title":"Operator","text":"For example, the operator called map() is analogous to the Array method of the same name. Just like the array method map((d) -> d ^ 2, [ 1, 2, 3 ]) yields [ 1, 4, 9 ], the Observable emits 1, 4, 9:","category":"page"},{"location":"operators/about/","page":"Operator","title":"Operator","text":"source = from([ 1, 2, 3 ])\nsubscribe!(source |> map(Int, (d) -> d ^ 2), lambda(\n    on_next = (d) -> println(d)\n))\n\n// Logs:\n// 1\n// 4\n// 9","category":"page"},{"location":"operators/about/","page":"Operator","title":"Operator","text":"Another useful operator is first():","category":"page"},{"location":"operators/about/","page":"Operator","title":"Operator","text":"source = from([ 1, 2, 3 ])\nsubscribe!(source |> first(), lambda(\n    on_next     = (d) -> println(d),\n    on_complete = ()  -> \"Completed\"\n))\n\n// Logs:\n// 1\n// Completed","category":"page"},{"location":"operators/about/#Creation-operators","page":"Operator","title":"Creation operators","text":"","category":"section"},{"location":"operators/about/","page":"Operator","title":"Operator","text":"Distinct from pipeable operators, creation operators are functions that can be used to create an Observable with some common predefined behavior or by joining other Observables. For example: from([ 1, 2, 3 ]) creates an observable that will sequentially emit 1, 2, and 3.","category":"page"},{"location":"operators/about/","page":"Operator","title":"Operator","text":"source = from([ 1, 2, 3 ])\nsubscribe!(source, lambda(\n    on_next     = (d) -> println(\"Value: $d\"),\n    on_error    = (e) -> println(\"Oh no, error: $e\")\n    on_complete = ()  -> println(\"Completed\")\n))\n\n// Logs:\n// Value: 1\n// Value: 2\n// Value: 3\n// Completed","category":"page"},{"location":"operators/about/#Operators-piping","page":"Operator","title":"Operators piping","text":"","category":"section"},{"location":"operators/about/","page":"Operator","title":"Operator","text":"Pipeable operators are special objects that can be used like ordinary functions with on_call!(operator, source). In practice however they tend to accumulate and quickly grow unreadable: on_call!(operator1, on_call!(operator2, on_call!(operator3, source))). Therefore, Rocket.jl overloads |> for operators and Observables:","category":"page"},{"location":"operators/about/","page":"Operator","title":"Operator","text":"using Rocket\n\nsource = from(1:100) |> filter((d) -> d % 2 === 0) |> map(Int, (d) -> d ^ 2) |> sum()\n\nsubscribe!(source, logger())\n\n// Logs\n// [LogActor] Data: 171700\n// [LogActor] Completed","category":"page"},{"location":"operators/about/","page":"Operator","title":"Operator","text":"It is also possible to create an operator composition with + or |>. It might be useful to create an alias for some often used operator chain","category":"page"},{"location":"operators/about/","page":"Operator","title":"Operator","text":"using Rocket\n\nmapAndFilter = map(Int, d -> d ^ 2) + filter(d -> d % 2 == 0) \n\nsource = from(1:5) |> mapAndFilter\n\nsubscribe!(source, logger())\n\n// Logs\n// [LogActor] Data: 4\n// [LogActor] Data: 16\n// [LogActor] Completed\n\nmapAndFilterAndSum = mapAndFilter + sum()\n\nsource = from(1:5) |> mapAndFilterAndSum\n\nsubscribe!(source, logger())\n\n// Logs\n// [LogActor] Data: 20\n// [LogActor] Completed","category":"page"},{"location":"operators/about/","page":"Operator","title":"Operator","text":"For stylistic reasons, on_call!(operator, source) is never used in practice - even if there is only one operator. Instead, source |> operator() is generally preferred.","category":"page"},{"location":"observables/types/iterable/#observable_iterable","page":"Iterable","title":"Iterable Observable","text":"","category":"section"},{"location":"observables/types/iterable/","page":"Iterable","title":"Iterable","text":"iterable","category":"page"},{"location":"observables/types/iterable/#Rocket.iterable","page":"Iterable","title":"Rocket.iterable","text":"iterable(iterator; scheduler::H = AsapScheduler()) where { H <: AbstractScheduler }\n\nCreation operator for the IterableObservable that wraps given iterator into an observable object.\n\nArguments\n\niterator: an iterator object to be wrapped an observable\nscheduler: optional, scheduler-like object\n\nNote\n\niterable operators does not create a copy of iterator. Any changes in the iterator object might be visible in the created observable. For side-effects free behavior consider using from creation operator which creates a copy of a given object with a collect function.\n\nExamples\n\nusing Rocket\n\nsource = iterable([ 0, 1, 2 ])\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Completed\n\nusing Rocket\n\nsource = iterable(\"Hello\")\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: H\n[LogActor] Data: e\n[LogActor] Data: l\n[LogActor] Data: l\n[LogActor] Data: o\n[LogActor] Completed\n\nSee also: ScheduledSubscribable, subscribe!, from\n\n\n\n\n\n","category":"function"},{"location":"observables/types/generate/#observable_generate","page":"Generate","title":"Generate Observable","text":"","category":"section"},{"location":"observables/types/generate/","page":"Generate","title":"Generate","text":"generate","category":"page"},{"location":"observables/types/generate/#Rocket.generate","page":"Generate","title":"Rocket.generate","text":"generate(initial::D, condition::C, iterator::I; scheduler::H = AsapScheduler()) where { D, C, I, H <: AbstractScheduler }\n\nGenerates an observable sequence by running a state-driven loop producing the sequence's elements, using the specified scheduler to send out observer messages.\n\nArguments\n\ninitial: initial state\ncondition: condition to terminate generation (upon returning false)\niterator: iteration step function\nscheduler: optional, scheduler-like object\n\nNote\n\niterator object should return objects of the same type as initial.\n\nExamples\n\nusing Rocket\n\nsource = generate(1, x -> x < 3, x -> x + 1)\nsubscribe!(source, logger())\n;\n\n# output\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Completed\n\nSee also: ScheduledSubscribable, subscribe!\n\n\n\n\n\n","category":"function"},{"location":"operators/filtering/ignore/#operator_ignore","page":"ignore","title":"Ignore operator","text":"","category":"section"},{"location":"operators/filtering/ignore/","page":"ignore","title":"ignore","text":"ignore","category":"page"},{"location":"operators/filtering/ignore/#Rocket.ignore","page":"ignore","title":"Rocket.ignore","text":"ignore(count::Int)\n\nCreates a ignore operator, which returns an Observable that skips the first count items emitted by the source Observable.\n\nArguments\n\ncount::Int: the number of times, items emitted by source Observable should be skipped.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource = from(1:5)\n\nsubscribe!(source |> ignore(2), logger())\n;\n\n# output\n\n[LogActor] Data: 3\n[LogActor] Data: 4\n[LogActor] Data: 5\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/filtering/ignore/#See-also","page":"ignore","title":"See also","text":"","category":"section"},{"location":"operators/filtering/ignore/","page":"ignore","title":"ignore","text":"Operators","category":"page"},{"location":"subjects/types/replay/#subject_replay","page":"Replay","title":"ReplaySubject","text":"","category":"section"},{"location":"subjects/types/replay/","page":"Replay","title":"Replay","text":"ReplaySubject\nReplaySubjectFactory","category":"page"},{"location":"subjects/types/replay/#Rocket.ReplaySubject","page":"Replay","title":"Rocket.ReplaySubject","text":"ReplaySubject(::Type{D}, size::Int) where D\nReplaySubject(::Type{D}, size::Int, factory::F) where { D, F <: AbstractSubjectFactory }\nReplaySubject(::Type{D}, size::Int, subject::S) where { D, S }\n\nA variant of Subject that \"replays\" or emits old values to new subscribers. It buffers a set number of values and will emit those values immediately to any new subscribers in addition to emitting new values to existing subscribers.\n\nSee also: ReplaySubjectFactory, Subject, SubjectFactory\n\n\n\n\n\n","category":"function"},{"location":"subjects/types/replay/#Rocket.ReplaySubjectFactory","page":"Replay","title":"Rocket.ReplaySubjectFactory","text":"ReplaySubjectFactory(size::Int, factory::F) where { F <: AbstractSubjectFactory }\nReplaySubjectFactory(size::Int; scheduler::H = AsapScheduler()) where { H <: AbstractScheduler }\n\nA variant of SubjectFactory that creates an instance of ReplaySubject.\n\nSee also: SubjectFactory, AbstractSubjectFactory, ReplaySubject, Subject\n\n\n\n\n\n","category":"function"},{"location":"subjects/types/replay/#Description","page":"Replay","title":"Description","text":"","category":"section"},{"location":"subjects/types/replay/","page":"Replay","title":"Replay","text":"A ReplaySubject is similar to a BehaviorSubject in that it can send old values to new subscribers, but it can also record a part of the Observable execution.","category":"page"},{"location":"subjects/types/replay/","page":"Replay","title":"Replay","text":"note: Note\nA ReplaySubject records multiple values from the Observable execution and replays them to new subscribers.","category":"page"},{"location":"subjects/types/replay/#Examples","page":"Replay","title":"Examples","text":"","category":"section"},{"location":"subjects/types/replay/","page":"Replay","title":"Replay","text":"When creating a ReplaySubject, you can specify how many values to replay:","category":"page"},{"location":"subjects/types/replay/","page":"Replay","title":"Replay","text":"using Rocket\n\nsubject = ReplaySubject(Int, 3) # buffer 3 values for new subscribers\n\nsubscription1 = subscribe!(subject, logger(\"1\"))\n\nnext!(subject, 1)\nnext!(subject, 2)\nnext!(subject, 3)\nnext!(subject, 4)\n\nsubscription2 = subscribe!(subject, logger(\"2\"))\n\nnext!(subject, 5)\n\nunsubscribe!(subscription1)\nunsubscribe!(subscription2)\n\n// Logs\n// [1] Data: 1\n// [1] Data: 2\n// [1] Data: 3\n// [1] Data: 4\n// [2] Data: 2\n// [2] Data: 3\n// [2] Data: 4\n// [1] Data: 5\n// [2] Data: 5","category":"page"},{"location":"observables/about/#section_observables","page":"Observable","title":"Observables","text":"","category":"section"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"Observables are lazy Push collections of multiple values. They fill the missing spot in the following table:","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"Type Single Mutliple\nPull Function Iterator\nPush Promise Observable","category":"page"},{"location":"observables/about/#First-example","page":"Observable","title":"First example","text":"","category":"section"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"For example, the following code specifies an Observable that pushes the values 1, 2, 3 immediately (synchronously) when subscribed to, and the value 4 after one second has passed since subscription.","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"using Rocket\n\nsource = make(Int) do actor\n    next!(actor, 1)\n    next!(actor, 2)\n    next!(actor, 3)\n    setTimeout(1000) do\n        next!(actor, 4)\n        complete!(actor)\n    end\nend","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"To invoke the Observable and inspect these values, we need to subscribe to it. It is important to note that observables are lazy collections which means they don't emit anything until someone subscribes to it. Every subscription spawns its own independent execution of observable. There are some exceptions to this rule, e.g. Subjects and some operators (share(), etc..) which may change this behaviour","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"using Rocket\n\nsource = make(Int) do actor\n    next!(actor, 1)\n    next!(actor, 2)\n    next!(actor, 3)\n    setTimeout(1000) do\n        next!(actor, 4)\n        complete!(actor)\n    end\nend\n\nprintln(\"Just before subscribe\")\nsubscribe!(source, lambda(\n    on_next     = (d) -> println(d),\n    on_complete = ()  -> println(\"Completed\")\n))\nprintln(\"Just after subscribe\")\n\n# Logs\n# Just before subscribe\n# 1\n# 2\n# 3\n# Just after subscribe\n# 4\n# Completed","category":"page"},{"location":"observables/about/#Pull-vs-Push","page":"Observable","title":"Pull vs Push","text":"","category":"section"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"Pull and Push are two different protocols that describe how a data Producer communicates with a data Consumer.","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"In a Pull system, the Consumer determines when it receives data from the Producer. The Producer itself is unaware of when the data are delivered to the Consumer.","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"Every Julia Function is a Pull system. The function is a Producer of data, and the code that calls the function is consuming data by \"pulling\" a return value from the call.","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"Type PRODUCER CONSUMER\nPull Passive: produces data when requested. Active: decides when data is requested.\nPush Active: produces data at its own pace. Passive: reacts to received data.","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"In Push systems, the Producer determines when to send data to the Consumer. The Consumer is unaware of when it will receive that data.","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"Futures and promises are the most common type of Push systems today. A Promise (the Producer) delivers a resolved value to registered callbacks (the Consumers). Unlike functions, it is the Promise that determines precisely when a value is \"pushed\" to the callbacks.","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"Rocket.jl introduces Observables, a new Push system for Julia. An Observable is a Producer of multiple values, \"pushing\" them to Observers (Consumers or Actors).","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"A Function is a lazily evaluated computation that synchronously returns a single value on invocation.\nA Generator is a lazily evaluated computation that synchronously returns zero to (potentially) infinite values on iteration.\nA Promise is a computation that may (or may not) eventually return a single value.\nAn Observable is a lazily evaluated computation that can synchronously or asynchronously return zero to (potentially) infinite values from the time it's invoked.","category":"page"},{"location":"observables/about/#Observables-as-generalizations-of-functions","page":"Observable","title":"Observables as generalizations of functions","text":"","category":"section"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"In contrast to functions, Observables can \"return\" multiple values over time. For example, functions can't do this:","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"function foo()\n    println(\"Hello!\")\n    return 0\n    return 1 # Dead code, will never happen\nend","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"Observables, however, can do this:","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"using Rocket\n\nfoo = make(Int) do actor\n    next!(actor, 0)\n    next!(actor, 1)\n    complete!(actor)\nend\n","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"Observables can also \"return\" values asynchronously after some time:","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"using Rocket\n\nfoo = make(Int) do actor\n    setTimeout(1000) do\n        next!(actor, 0)\n        complete!(actor)\n    end\nend","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"Assume we have a function foo and some observable:","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"Function call foo(args...) means \"give me one value synchronously\" (push strategy)\nIn contrast subscription to an observable with subscribe(observable, ...) means \"notify me about any amount of values, either synchronously or asynchronously\" (pull strategy)","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"When a new value is available in an observable we say that the observable emits or generates an update. Values that are generated by an observable are sometimes also called future values, because there is no principled way to predict when an observable will generate a new value. In some programming languages, observables are referred to as generators or streams and we will use all three terms interchangeably.","category":"page"},{"location":"observables/about/#Anatomy-of-an-Observable","page":"Observable","title":"Anatomy of an Observable","text":"","category":"section"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"Observables are (1) created using creation operators (it is also possible to build an Observable from scratch with custom logic); (2) subscribed to with an Actor; (3) execute to deliver next! / error! / complete! notifications to the Actor, and (4) their execution may be disposed. These four aspects are all encoded in an Observable instance, but some of these aspects are related to other types, such as Subscribable and Subscription.","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"The core responsibilities of an Observable are:","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"Creating Observables\nSubscribing to Observables\nExecuting the Observable\nDisposing Observables","category":"page"},{"location":"observables/about/#Creating-Observables","page":"Observable","title":"Creating Observables","text":"","category":"section"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"You can create an Observable in various ways using Creation operators. You can also build an Observable from scratch. To see how you can build an Observable with custom logic, consult the API Section.","category":"page"},{"location":"observables/about/#Subscribing-to-Observables","page":"Observable","title":"Subscribing to Observables","text":"","category":"section"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"The Observable source in the example can be subscribed to.","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"using Rocket\n\nsubscribe!(source, lambda(\n    on_next = (d) -> println(d)\n))","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"This example shows how subscribe calls are not shared among multiple Actors of the same Observable. When calling subscribe! with an Actor, the function on_subscribe! that is attached to this particular Observable is executed for that given actor. Each call to subscribe! triggers its own independent setup for that given actor.","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"note: Note\nSubscribing to an Observable is like calling a function, providing callbacks where the data will be delivered to.","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"subscribe! function also supports multiple subscriptions at once. If the input argument to the subscribe! function is a tuple or a vector, it will first check that all of the arguments are valid source objects and actors and if its true will subscribe from each of them individually.","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"\nsource1 = Subject(Int)\nsource2 = Subject(Int)\n\nsubscriptions = subscribe!([\n    (source1, logger()),\n    (source2, logger()),\n])\n\n# Later on\n# unsubscribe!(subscriptions)\n","category":"page"},{"location":"observables/about/#Executing-Observables","page":"Observable","title":"Executing Observables","text":"","category":"section"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"The execution produces multiple values over time, either synchronously or asynchronously.","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"An Observable Execution can deliver three types of notifications:","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"Next: sends a value, such as an Int, String, Dict, etc.;\nError: sends any error as a value;\nComplete: does not send a value.","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"\"Next\" notifications are the most important and most common type: they represent actual data being delivered to an subscriber. \"Error\" and \"Complete\" notifications terminate the Observable Execution.","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"note: Note\nIn an Observable Execution, any number of Next notifications may be delivered. However, once a single Error or Complete notification is delivered, nothing else can be delivered afterwards.","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"The following is an example of an Observable execution that delivers three Next notifications and subsequently completes:","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"using Rocket\n\nsource = make(Int) do actor\n    next!(actor, 1)\n    next!(actor, 2)\n    next!(actor, 3)\n    complete!(actor)\nend\n\n# or the same with creation operator\n\nsource = from([ 1, 2, 3 ])","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"It is advised to wrap any code in subscribe by a try/catch block that delivers an Error notification upon an exception:","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"using Rocket\n\nsource = make(Int) do actor\n    try\n        next!(actor, 1)\n        next!(actor, 2)\n        next!(actor, 3)\n        complete!(actor)\n    catch e\n        error!(actor, e)\n    end\nend\n","category":"page"},{"location":"observables/about/#Disposing-Observable-Executions","page":"Observable","title":"Disposing Observable Executions","text":"","category":"section"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"It is common for an Actor to abort execution of an Observable Execution. Once the Actor is done receiving values, it may stop the execution in order to free computation power or memory resources.","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"When subscribe! is called, the Actor gets attached to the newly created Observable execution. This call also returns an object, the Subscription:","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"subscription = subscribe!(source, actor)","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"The Subscription represents the ongoing execution, and has a minimal API that allows you to cancel the execution. Read more about Subscription type here.","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"With","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"unsubscribe!(subscription)","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"you can cancel the ongoing execution.","category":"page"},{"location":"observables/about/","page":"Observable","title":"Observable","text":"note: Note\nsubscribe! returns a Subscription that represents the ongoing execution. Simply call unsubscribe! on the Subscription to cancel the execution.","category":"page"},{"location":"operators/utility/default_if_empty/#operator_ref_default_if_empty","page":"default_if_empty","title":"DefaultIfEmpty Operator","text":"","category":"section"},{"location":"operators/utility/default_if_empty/","page":"default_if_empty","title":"default_if_empty","text":"default_if_empty","category":"page"},{"location":"operators/utility/default_if_empty/#Rocket.default_if_empty","page":"default_if_empty","title":"Rocket.default_if_empty","text":"default_if_empty(value::T)\ndefault_if_empty(callback::Function)\n\nCreates a default_if_empty operator, which emits a given value if the source Observable completes without emitting any next value, otherwise mirrors the source Observable. Optionally accepts a zero-argument callback that will be executed to generate default value. Note: Callback function's output is always converted to the eltype of the original observable.\n\nusing Rocket\n\nsource = completed(Int) |> default_if_empty(0)\n\nsubscribe!(source, logger())\n;\n\n# output\n[LogActor] Data: 0\n[LogActor] Completed\n\nusing Rocket\n\nsource = completed(Int) |> default_if_empty(() -> 42)\n\nsubscribe!(source, logger())\n;\n\n# output\n[LogActor] Data: 42\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, logger, map\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/default_if_empty/#Description","page":"default_if_empty","title":"Description","text":"","category":"section"},{"location":"operators/utility/default_if_empty/","page":"default_if_empty","title":"default_if_empty","text":"default_if_empty emits the values emitted by the source Observable or a specified default value if the source Observable is empty (completes without having emitted any next value).","category":"page"},{"location":"operators/utility/default_if_empty/#See-also","page":"default_if_empty","title":"See also","text":"","category":"section"},{"location":"operators/utility/default_if_empty/","page":"default_if_empty","title":"default_if_empty","text":"Operators","category":"page"},{"location":"observables/types/never/#observable_never","page":"Never","title":"Never Observable","text":"","category":"section"},{"location":"observables/types/never/","page":"Never","title":"Never","text":"never","category":"page"},{"location":"observables/types/never/#Rocket.never","page":"Never","title":"Rocket.never","text":"never(T = Any)\n\nCreation operator for the NeverObservable that emits neither values nor errors nor the completion notification. It can be used for testing purposes or for composing with other Observables. Please note that by never emitting a complete notification, this Observable keeps the subscription from being disposed automatically. Subscriptions need to be manually disposed.\n\nArguments\n\nT: Type of Observable data, optional, Any is the default\n\nExamples\n\nusing Rocket\n\nsource = never()\nsubscribe!(source, logger())\n;\n\n# output\n\n\nSee also: NeverObservable, subscribe!, logger\n\n\n\n\n\n","category":"function"},{"location":"observables/types/never/","page":"Never","title":"Never","text":"NeverObservable","category":"page"},{"location":"observables/types/never/#Rocket.NeverObservable","page":"Never","title":"Rocket.NeverObservable","text":"NeverObservable{D}()\n\nAn Observable that emits no items to the Observer and never completes.\n\nType parameters\n\nD: Type of Observable data\n\nSee also: Subscribable, never\n\n\n\n\n\n","category":"type"},{"location":"operators/utility/about/#Utility-category","page":"About utility operators","title":"Utility category","text":"","category":"section"},{"location":"operators/utility/about/","page":"About utility operators","title":"About utility operators","text":"There are operators for different purposes, and they may be categorized as: creation, transformation, filtering, joining, multicasting, error handling, utility, etc. In the following list you will find all the operators organized in utility category.","category":"page"},{"location":"operators/utility/about/","page":"About utility operators","title":"About utility operators","text":"tap\ntap_on_subscribe\ntap_on_unsubscribe\ntap_on_complete\ndelay\nsafe\nnoop\nref_count\nasync\ndefault_if_empty\nerror_if_empty\nskip_next\nskip_error\nskip_complete\ndiscontinue\nlimit_subscribers","category":"page"},{"location":"operators/utility/about/#See-also","page":"About utility operators","title":"See also","text":"","category":"section"},{"location":"operators/utility/about/","page":"About utility operators","title":"About utility operators","text":"Operators","category":"page"},{"location":"operators/all/#operators_list","page":"All","title":"List of all available operators","text":"","category":"section"},{"location":"operators/all/","page":"All","title":"All","text":"There are operators for different purposes, and they may be categorized as: creation, transformation, filtering, joining, multicasting, error handling, utility, etc.","category":"page"},{"location":"operators/all/#Creation-operators","page":"All","title":"Creation operators","text":"","category":"section"},{"location":"operators/all/","page":"All","title":"All","text":"make\nof\nfrom\niterable\nfaulted\nnever\ncompleted\ntimer\ninterval\nproxy\nfile\ncombined\nrace\nconnectable\nmerged\nconcat\ngenerate\nnetwork\ndefer\nzipped","category":"page"},{"location":"operators/all/#Transformation-operators","page":"All","title":"Transformation operators","text":"","category":"section"},{"location":"operators/all/","page":"All","title":"All","text":"map\nmap_to\nscan\naccumulated\nenumerate\nuppercase\nlowercase\nto_array\nswitch_map\nswitch_map_to\nmerge_map\nconcat_map\nconcat_map_to\nexhaust_map\nstart_with\npairwise\nsubstitute\noverride","category":"page"},{"location":"operators/all/#Filtering-operators","page":"All","title":"Filtering operators","text":"","category":"section"},{"location":"operators/all/","page":"All","title":"All","text":"filter\nfilter_type\nsome\ntake\ntake_until\nfirst\nlast\nfind\nfind_index\nignore","category":"page"},{"location":"operators/all/#Mathematical-and-Aggregate-operators","page":"All","title":"Mathematical and Aggregate operators","text":"","category":"section"},{"location":"operators/all/","page":"All","title":"All","text":"count\nmax\nmin\nreduce\nsum","category":"page"},{"location":"operators/all/#Error-handling-operators","page":"All","title":"Error handling operators","text":"","category":"section"},{"location":"operators/all/","page":"All","title":"All","text":"catch_error\nrerun","category":"page"},{"location":"operators/all/#Join-operator","page":"All","title":"Join operator","text":"","category":"section"},{"location":"operators/all/","page":"All","title":"All","text":"with_latest","category":"page"},{"location":"operators/all/#Multicasting-operators","page":"All","title":"Multicasting operators","text":"","category":"section"},{"location":"operators/all/","page":"All","title":"All","text":"multicast\npublish\npublish_behavior\npublish_replay\nshare\nshare_replay","category":"page"},{"location":"operators/all/#Utility-operators","page":"All","title":"Utility operators","text":"","category":"section"},{"location":"operators/all/","page":"All","title":"All","text":"tap\ntap_on_subscribe\ntap_on_unsubscribe\ntap_on_complete\ndelay\nsafe\nnoop\nref_count\nasync\ndefault_if_empty\nerror_if_empty\nskip_next\nskip_error\nskip_complete\ndiscontinue\nlimit_subscribers","category":"page"},{"location":"observables/types/concat/#observable_concat","page":"Concat","title":"Concat Observable","text":"","category":"section"},{"location":"observables/types/concat/","page":"Concat","title":"Concat","text":"concat","category":"page"},{"location":"observables/types/concat/#Rocket.concat","page":"Concat","title":"Rocket.concat","text":"concat(sources...)\nconcat(sources::S) where { S <: Tuple }\n\nCombines multiple Observables to create an Observable which sequentially emits all values from given Observable and then moves on to the next. All values of each passed Observable merged into a single Observable, in order, in serial fashion.\n\nArguments\n\nsources: input sources\n\nExamples\n\nusing Rocket\n\nsource1 = of(1)\nsource2 = of(2)\n\nsubscribe!(concat(source1, source2), logger())\n;\n\n# output\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Completed\n\nusing Rocket\n\nsource1 = of(1) |> async()\nsource2 = of(2)\n\nsubscribe!(concat(source1, source2), logger())\n;\n\n# output\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Completed\n\nSee also: Subscribable, subscribe!\n\n\n\n\n\n","category":"function"},{"location":"actors/types/lambda/#actor_lambda","page":"Lambda","title":"Lambda actor","text":"","category":"section"},{"location":"actors/types/lambda/","page":"Lambda","title":"Lambda","text":"lambda","category":"page"},{"location":"actors/types/lambda/#Rocket.lambda","page":"Lambda","title":"Rocket.lambda","text":"lambda(; on_next = nothing, on_error = nothing, on_complete = nothing)\nlambda(::Type{T}; on_next = nothing, on_error = nothing, on_complete = nothing) where T\n\nCreation operator for the 'LambdaActor' actor.\n\nExamples\n\nusing Rocket\n\nactor = lambda(Int; on_next = (d) -> println(d))\nactor isa LambdaActor{Int}\n\n# output\ntrue\n\nSee also: LambdaActor, AbstractActor\n\n\n\n\n\n","category":"function"},{"location":"actors/types/lambda/","page":"Lambda","title":"Lambda","text":"LambdaActor","category":"page"},{"location":"actors/types/lambda/#Rocket.LambdaActor","page":"Lambda","title":"Rocket.LambdaActor","text":"LambdaActor{D, N, E, C}(on_next::N, on_error::E, on_complete::C) where D\n\nLambda actor wraps on_next, on_error, on_complete callbacks for data, error and complete events. Should not be used explicitly, use lambda creation operator instead.\n\nConstructor arguments\n\non_next: Callback for data event. Optional. Default is nothing.\non_error: Callback for error event. Optional. Default is nothing.\non_complete: Callback for complete event. Optional. Default is nothing.\n\nSee also: Actor, lambda\n\n\n\n\n\n","category":"type"},{"location":"operators/utility/error_if_empty/#operator_ref_error_if_empty","page":"error_if_empty","title":"ErrorIfEmpty Operator","text":"","category":"section"},{"location":"operators/utility/error_if_empty/","page":"error_if_empty","title":"error_if_empty","text":"error_if_empty","category":"page"},{"location":"operators/utility/error_if_empty/#Rocket.error_if_empty","page":"error_if_empty","title":"Rocket.error_if_empty","text":"error_if_empty(err)\n\nCreates a error_if_empty operator, which emits a given error if the source Observable completes without emitting any next value, otherwise mirrors the source Observable.\n\nusing Rocket\n\nsource = completed(Int) |> error_if_empty(\"Empty\")\n\nsubscribe!(source, logger())\n;\n\n# output\n[LogActor] Error: Empty\n\nSee also: AbstractOperator, InferableOperator, logger, map\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/error_if_empty/#Description","page":"error_if_empty","title":"Description","text":"","category":"section"},{"location":"operators/utility/error_if_empty/","page":"error_if_empty","title":"error_if_empty","text":"error_if_empty emits the values emitted by the source Observable or a specified error message if the source Observable is empty (completes without having emitted any next value).","category":"page"},{"location":"operators/utility/error_if_empty/#See-also","page":"error_if_empty","title":"See also","text":"","category":"section"},{"location":"operators/utility/error_if_empty/","page":"error_if_empty","title":"error_if_empty","text":"Operators","category":"page"},{"location":"subjects/types/subject/#subject","page":"Subject","title":"Subject","text":"","category":"section"},{"location":"subjects/types/subject/","page":"Subject","title":"Subject","text":"Subject\nSubjectFactory","category":"page"},{"location":"subjects/types/subject/#Rocket.Subject","page":"Subject","title":"Rocket.Subject","text":"Subject(::Type{D}; scheduler::H = AsapScheduler())\n\nA Subject is a special type of Observable that allows values to be multicasted to many Observers. Subjects are like EventEmitters. Every Subject is an Observable and an Actor. You can subscribe to a Subject, and you can call next! to feed values as well as error! and complete!.\n\nNote: By convention, every actor subscribed to a Subject observable is not allowed to throw exceptions during next!, error! and complete! calls.  Doing so would lead to undefined behaviour. Use safe() operator to bypass this rule. \n\nSee also: SubjectFactory, ReplaySubject, BehaviorSubject, safe\n\n\n\n\n\n","category":"type"},{"location":"subjects/types/subject/#Rocket.SubjectFactory","page":"Subject","title":"Rocket.SubjectFactory","text":"SubjectFactory(scheduler::H) where { H <: AbstractScheduler }\n\nA base subject factory that creates an instance of Subject with specified scheduler.\n\nSee also: AbstractSubjectFactory, Subject\n\n\n\n\n\n","category":"type"},{"location":"subjects/types/subject/#Description","page":"Subject","title":"Description","text":"","category":"section"},{"location":"subjects/types/subject/","page":"Subject","title":"Subject","text":"Every Subject is an Observable. Given a Subject, you can subscribe to it, providing an Actor, which will start receiving values normally. From the perspective of the Observer, it cannot tell whether the Observable execution is coming from a plain unicast Observable or a Subject.","category":"page"},{"location":"subjects/types/subject/","page":"Subject","title":"Subject","text":"Internally to the Subject, subscribe does not invoke a new execution that delivers values. It simply registers the given Observer in a list of Observers.","category":"page"},{"location":"subjects/types/subject/","page":"Subject","title":"Subject","text":"Every Subject is an Actor. It is an object with the methods next!, error!, and complete!. To feed a new value to the Subject, just call next!(subject, theValue), and it will be multicasted to the Actors registered to listen to the Subject.","category":"page"},{"location":"subjects/types/subject/","page":"Subject","title":"Subject","text":"note: Note\nBy convention, every actor subscribed to a Subject observable is not allowed to throw exceptions during next!, error! and complete! calls.  Doing so would lead to undefined behaviour. Use safe() operator to bypass this rule. ","category":"page"},{"location":"subjects/types/subject/#Examples","page":"Subject","title":"Examples","text":"","category":"section"},{"location":"subjects/types/subject/","page":"Subject","title":"Subject","text":"In the following example, the BehaviorSubject is initialized with the value 0 which the first Observer receives when it subscribes. The second Observer receives the value 2 even though it subscribed after the value 2 was sent.","category":"page"},{"location":"subjects/types/subject/","page":"Subject","title":"Subject","text":"using Rocket\n\nsubject = Subject(Int)\n\nsubscription1 = subscribe!(subject, logger(\"1\"))\n\nnext!(subject, 1)\nnext!(subject, 2)\n\nsubscription2 = subscribe!(subject, logger(\"2\"))\n\nnext!(subject, 3)\n\nunsubscribe!(subscription1)\nunsubscribe!(subscription2)\n\n// Logs\n// [1] Data: 1\n// [1] Data: 2\n// [1] Data: 3\n// [2] Data: 3","category":"page"},{"location":"utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"setTimeout\nRocket.combined_type\nRocket.union_type","category":"page"},{"location":"utils/#Rocket.setTimeout","page":"Utils","title":"Rocket.setTimeout","text":"setTimeout(f::Function, timeout::Int)\n\nCreates a Task which will asynchornously invoke fucntion f after specified timeout time in milliseconds.\n\nArguments\n\nf::Function, function to be invoked asynchronously\ntimeout::Int, timeout in milliseconds\n\nExamples\n\nusing Rocket\nusing Dates\n\nprintln(\"Before: \", Dates.format(now(), \"MM:SS\"))\nsetTimeout(1000) do\n    println(\"Inside: \", Dates.format(now(), \"MM:SS\"))\nend\nprintln(\"Right after: \", Dates.format(now(), \"MM:SS\"))\n;\n\n# Logs\n# Before: 20:59\n# Right after: 20:59\n# Inside: 21:00\n\n\n\n\n\n","category":"function"},{"location":"utils/#Rocket.combined_type","page":"Utils","title":"Rocket.combined_type","text":"combined_type(sources)\n\nReturns a Tuple el-type of observable el-types in sources argument in the same order\n\n\n\n\n\n","category":"function"},{"location":"utils/#Rocket.union_type","page":"Utils","title":"Rocket.union_type","text":"union_type(sources)\n\nReturns a Union el-type of observable el-types in sources argument\n\n\n\n\n\n","category":"function"},{"location":"utils/#Helpers","page":"Utils","title":"Helpers","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"Rocket.@MStorage\nRocket.setstorage!","category":"page"},{"location":"utils/#Rocket.@MStorage","page":"Utils","title":"Rocket.@MStorage","text":"@MStorage(n::Int)\n\nHelper function to generate tuple-like structure MStorageN, but with mutable fields and empty constructor. It is possible then to take a snapshot(::MStorage) which returns a tuple with the same types and values from storage. Some operators and observables use pregenerated MStorage to instatiate uninitialized mutable storage in case when stream is allowed to not emit any values before completion.\n\nGenerated structure layout\n\nstruct MStorageN{V1, V2, ..., VN}\n    v1 :: V1\n    v2 :: V2\n    ...\n    vn :: VN\nend\n\nSee also: setstorage!\n\n\n\n\n\n","category":"macro"},{"location":"utils/#Rocket.setstorage!","page":"Utils","title":"Rocket.setstorage!","text":"setstorage!(s, v, ::Val{I}) where I\n\nThis function can be used to set a new value v for storage s with a given value v and index I. Using parametrized Val{I} for indexing ensures for index to be resolved at compile-time and if-else branch optimization.\n\nSee also: @MStorage\n\n\n\n\n\n","category":"function"},{"location":"observables/types/completed/#observable_completed","page":"Completed","title":"Completed Observable","text":"","category":"section"},{"location":"observables/types/completed/","page":"Completed","title":"Completed","text":"completed","category":"page"},{"location":"observables/types/completed/#Rocket.completed","page":"Completed","title":"Rocket.completed","text":"completed(::Type{T} = Any; scheduler::H = AsapScheduler()) where { T, H <: AbstractScheduler }\n\nCreation operator for the CompletedObservable that emits no items to the Actor and immediately sends a complete notification on subscription.\n\nArguments\n\nT: type of output data source, optional, Any is the default\nscheduler: optional, scheduler-like object\n\nExamples\n\nusing Rocket\n\nsource = completed(Int)\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Completed\n\n\nSee also: CompletedObservable, subscribe!, logger\n\n\n\n\n\n","category":"function"},{"location":"observables/types/completed/","page":"Completed","title":"Completed","text":"CompletedObservable","category":"page"},{"location":"observables/types/completed/#Rocket.CompletedObservable","page":"Completed","title":"Rocket.CompletedObservable","text":"CompletedObservable{D, H}(scheduler::H)\n\nObservable that emits no items to the Actor and just sends a complete notification on subscription.\n\nConstructor arguments\n\nscheduler: Scheduler-like object\n\nSee also: Subscribable, completed\n\n\n\n\n\n","category":"type"},{"location":"operators/utility/tap/#operator_tap","page":"tap","title":"Tap Operator","text":"","category":"section"},{"location":"operators/utility/tap/","page":"tap","title":"tap","text":"tap","category":"page"},{"location":"operators/utility/tap/#Rocket.tap","page":"tap","title":"Rocket.tap","text":"tap(tapFn::F) where { F <: Function }\n\nCreates a tap operator, which performs a side effect for every emission on the source Observable, but return an Observable that is identical to the source.\n\nArguments\n\ntapFn::Function: side-effect tap function with (data) -> Nothing signature\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> tap((d) -> println(\"In tap: $d\")), logger())\n;\n\n# output\n\nIn tap: 1\n[LogActor] Data: 1\nIn tap: 2\n[LogActor] Data: 2\nIn tap: 3\n[LogActor] Data: 3\n[LogActor] Completed\n\n\nSee also: tap_on_subscribe, tap_on_complete, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/tap/#Description","page":"tap","title":"Description","text":"","category":"section"},{"location":"operators/utility/tap/","page":"tap","title":"tap","text":"Returns an Observable that resembles the source Observable, but modifies it so that the provided Observer is called to perform a side effect for every value emitted by the source.","category":"page"},{"location":"operators/utility/tap/","page":"tap","title":"tap","text":"This operator is useful for debugging your Observables, verifying correct values, or performing other side effects.","category":"page"},{"location":"operators/utility/tap/","page":"tap","title":"tap","text":"Note: this operator differs from a subscribe on the Observable. If the Observable returned by tap is not subscribed, the side effects specified by the Observer will never happen. tap therefore simply spies on existing execution, it does not trigger an execution to happen like subscribe does.","category":"page"},{"location":"operators/utility/tap/#See-also","page":"tap","title":"See also","text":"","category":"section"},{"location":"operators/utility/tap/","page":"tap","title":"tap","text":"Operators","category":"page"},{"location":"observables/types/network/#observable_network","page":"Network","title":"Network Observable","text":"","category":"section"},{"location":"observables/types/network/","page":"Network","title":"Network","text":"network","category":"page"},{"location":"observables/types/network/#Rocket.network","page":"Network","title":"Rocket.network","text":"network(::Type{D}, port::Int)             where D\nnetwork(::Type{D}, address::A, port::Int) where { D, A <: IPAddr }\n\nnetwork(::Type{Vector{D}}, port::Int, buffer_size::Int)             where D\nnetwork(::Type{Vector{D}}, address::A, port::Int, buffer_size::Int) where { D, A <: IPAddr }\n\nCreation operator for the NetworkObservable that emits messages from the server with specified address and port arguments.\n\nSee also: NetworkObservable, subscribe!\n\n\n\n\n\n","category":"function"},{"location":"observables/types/network/","page":"Network","title":"Network","text":"NetworkObservable","category":"page"},{"location":"observables/types/network/#Rocket.NetworkObservable","page":"Network","title":"Rocket.NetworkObservable","text":"NetworkObservable{D, Address, Port, S}()\n\nNetworkObservable listens for the messages of type D from remote server with specified Address and Port parameters.\n\nSee also: network, Subscribable\n\n\n\n\n\n","category":"type"},{"location":"observables/types/function/#observable_function","page":"Function","title":"Function Observable","text":"","category":"section"},{"location":"observables/types/function/","page":"Function","title":"Function","text":"make","category":"page"},{"location":"observables/types/function/#Rocket.make","page":"Function","title":"Rocket.make","text":"make(f::Function, type::Type{D})\n\nCreation operator for the FunctionObservable.\n\nArguments\n\nf: function to be invoked on subscription\ntype: type of data in observable\n\nExamples\n\nusing Rocket\n\nsource = make(Int) do actor\n    next!(actor, 0)\n    complete!(actor)\nend\n\nsubscription = subscribe!(source, logger());\nunsubscribe!(subscription)\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Completed\n\n\nusing Rocket\n\nsource = make(Int) do actor\n    next!(actor, 0)\n    setTimeout(100) do\n        next!(actor, 1)\n        complete!(actor)\n    end\nend\n\nsubscription = subscribe!(source, logger())\nunsubscribe!(subscription)\n;\n\n# output\n\n[LogActor] Data: 0\n\nSee also: FunctionObservable, subscribe!, logger\n\n\n\n\n\n","category":"function"},{"location":"observables/types/function/","page":"Function","title":"Function","text":"FunctionObservable","category":"page"},{"location":"observables/types/function/#Rocket.FunctionObservable","page":"Function","title":"Rocket.FunctionObservable","text":"FunctionObservable{D}(f::F)\n\nFunctionObservable wraps a callback `f`, which is called when the Observable is initially subscribed to.\nThis function is given an Actor, to which new values can be nexted (with `next!(actor, data)`),\nor an `error!` method can be called to raise an error, or `complete!` can be called to notify of a successful completion.\n\n# Arguments\n- `f::F`: function to be invoked on subscription\n\nSee also: [`Subscribable`](@ref), [`make`](@ref)\n\n\n\n\n\n","category":"type"},{"location":"observables/types/race/#observable_race","page":"Race","title":"Race Observable","text":"","category":"section"},{"location":"observables/types/race/","page":"Race","title":"Race","text":"race","category":"page"},{"location":"observables/types/race/#Rocket.race","page":"Race","title":"Rocket.race","text":"race(sources...)\nrace(sources::S) where { S <: Tuple }\n\nCombines multiple Observables to create an Observable that mirrors the output of the first Observable to emit an item. Essentially it subscribes to the observable that was the first to start emitting.\n\nArguments\n\nsources: input sources\n\nExamples\n\nusing Rocket\n\nsource1 = of(1)\nsource2 = of(2)\n\nsubscribe!(race(source1, source2), logger())\n;\n\n# output\n[LogActor] Data: 1\n[LogActor] Completed\n\nusing Rocket\n\nsource1 = of(1) |> async()\nsource2 = of(2)\n\nsubscribe!(race(source1, source2), logger())\n;\n\n# output\n[LogActor] Data: 2\n[LogActor] Completed\n\nSee also: Subscribable, subscribe!\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/concat_map_to/#operator_concat_map_to","page":"concat_map_to","title":"ConcatMapTo Operator","text":"","category":"section"},{"location":"operators/transformation/concat_map_to/","page":"concat_map_to","title":"concat_map_to","text":"concat_map_to","category":"page"},{"location":"operators/transformation/concat_map_to/#Rocket.concat_map_to","page":"concat_map_to","title":"Rocket.concat_map_to","text":"switch_map_to(inner_observable)\n\nCreates a switch_map_to operator, which returns an observable of values merged together by joining the passed observable with itself, one after the other, for each value emitted from the source. Essentially it projects each source value to the same Observable which is merged multiple times in a serialized fashion on the output Observable.\n\nArguments\n\ninner_observable: an Observable to replace each value from the source Observable.\n\nProducing\n\nStream of type <: Subscribable{R} where R refers to the eltype of inner_observable\n\nExamples\n\nusing Rocket\n\nsource = from([ 0, 0, 0 ])\nsubscribe!(source |> concat_map_to(from([ 1, 2, 3 ])), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Completed\n\nSee also: concat_map, AbstractOperator, RightTypedOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/concat_map_to/","page":"concat_map_to","title":"concat_map_to","text":"note: Note\nconcat_map_to is equivalent to concat_map with mappingFn set to (_) -> inner_observable.","category":"page"},{"location":"operators/transformation/concat_map_to/#See-also","page":"concat_map_to","title":"See also","text":"","category":"section"},{"location":"operators/transformation/concat_map_to/","page":"concat_map_to","title":"concat_map_to","text":"Operators, concat_map","category":"page"},{"location":"todo/#TODO","page":"TODO","title":"TODO","text":"","category":"section"},{"location":"todo/","page":"TODO","title":"TODO","text":"This package in under development and some features of the reactive framework not yet implemented.","category":"page"},{"location":"operators/mathematical/count/#operator_count","page":"count","title":"Count Operator","text":"","category":"section"},{"location":"operators/mathematical/count/","page":"count","title":"count","text":"count","category":"page"},{"location":"operators/mathematical/count/#Base.count","page":"count","title":"Base.count","text":"count()\n\nCreates a count operator, which counts the number of emissions on the source and emits that number when the source completes.\n\nProducing\n\nStream of type <: Subscribable{Int}\n\nExamples\n\nusing Rocket\n\nsource = from([ i for i in 1:42 ])\nsubscribe!(source |> count(), logger())\n;\n\n# output\n\n[LogActor] Data: 42\n[LogActor] Completed\n\n\nSee also: AbstractOperator, RightTypedOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/mathematical/count/#Description","page":"count","title":"Description","text":"","category":"section"},{"location":"operators/mathematical/count/","page":"count","title":"count","text":"count transforms an Observable that emits values into an Observable that emits a single value that represents the number of values emitted by the source Observable. If the source Observable terminates with an error, count will pass this error notification along without emitting a value first. If the source Observable does not terminate at all, count will neither emit a value nor terminate.","category":"page"},{"location":"operators/mathematical/count/#Example","page":"count","title":"Example","text":"","category":"section"},{"location":"operators/mathematical/count/","page":"count","title":"count","text":"Counts how many values source Observable have emitted before the complete event happened","category":"page"},{"location":"operators/mathematical/count/","page":"count","title":"count","text":"using Rocket\n\nsource = from([ i for i in 1:42 ])\nsubscribe!(source |> count(), logger())\n\n# output\n\n[LogActor] Data: 42\n[LogActor] Completed","category":"page"},{"location":"operators/mathematical/count/#See-also","page":"count","title":"See also","text":"","category":"section"},{"location":"operators/mathematical/count/","page":"count","title":"count","text":"Operators","category":"page"},{"location":"operators/transformation/map_to/#operator_map_to","page":"map_to","title":"MapTo Operator","text":"","category":"section"},{"location":"operators/transformation/map_to/","page":"map_to","title":"map_to","text":"map_to","category":"page"},{"location":"operators/transformation/map_to/#Rocket.map_to","page":"map_to","title":"Rocket.map_to","text":"map_to(value::T) where T\n\nCreates a map operator, which emits the given constant value on the output Observable every time the source Observable emits a value.\n\nArguments\n\nvalue::T: the constant value to map each source value to\n\nProducing\n\nStream of type <: Subscribable{T}\n\nExamples\n\nusing Rocket\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> map_to('a'), logger())\n;\n\n# output\n\n[LogActor] Data: a\n[LogActor] Data: a\n[LogActor] Data: a\n[LogActor] Completed\n\nSee also: map, AbstractOperator, RightTypedOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/map_to/#Description","page":"map_to","title":"Description","text":"","category":"section"},{"location":"operators/transformation/map_to/","page":"map_to","title":"map_to","text":"Takes a constant value as argument, and emits that whenever the source Observable emits a value. In other words, ignores the actual source value, and simply uses the emission moment to know when to emit the given value.","category":"page"},{"location":"operators/transformation/map_to/#See-also","page":"map_to","title":"See also","text":"","category":"section"},{"location":"operators/transformation/map_to/","page":"map_to","title":"map_to","text":"Operators","category":"page"},{"location":"observables/types/merged/#observable_merged","page":"Merged","title":"Merged Observable","text":"","category":"section"},{"location":"observables/types/merged/","page":"Merged","title":"Merged","text":"merged","category":"page"},{"location":"observables/types/merged/#Rocket.merged","page":"Merged","title":"Rocket.merged","text":"merged(sources::T) where { T <: Tuple }\n\nCreation operator for the MergeObservable with a given sources collected in a tuple. merge subscribes to each given input Observable (as arguments), and simply forwards (without doing any transformation) all the values from all the input Observables to the output Observable. The output Observable only completes once all input Observables have completed. Any error delivered by an input Observable will be immediately emitted on the output Observable.\n\nExamples\n\nusing Rocket\n\nobservable = merged((from(1:4), of(2.0), from(\"Hello\")))\n\nsubscribe!(observable, logger())\n;\n\n# output\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Data: 4\n[LogActor] Data: 2.0\n[LogActor] Data: H\n[LogActor] Data: e\n[LogActor] Data: l\n[LogActor] Data: l\n[LogActor] Data: o\n[LogActor] Completed\n\nusing Rocket\n\nsubject = Subject(Int, scheduler = AsyncScheduler())\n\nobservable = merged((subject, of(2.0), from(\"Hello\")))\n\nactor = sync(logger())\n\nsubscribe!(observable, actor)\n\nsetTimeout(200) do\n    next!(subject, 1)\n    complete!(subject)\nend\n\nwait(actor)\n;\n\n# output\n[LogActor] Data: 2.0\n[LogActor] Data: H\n[LogActor] Data: e\n[LogActor] Data: l\n[LogActor] Data: l\n[LogActor] Data: o\n[LogActor] Data: 1\n[LogActor] Completed\n\nSee also: Subscribable\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/uppercase/#operator_uppercase","page":"uppercase","title":"Uppercase Operator","text":"","category":"section"},{"location":"operators/transformation/uppercase/","page":"uppercase","title":"uppercase","text":"uppercase","category":"page"},{"location":"operators/transformation/uppercase/#Base.Unicode.uppercase","page":"uppercase","title":"Base.Unicode.uppercase","text":"uppercase()\n\nCreates an uppercase operator, which forces each value to be in upper case\n\nProducing\n\nStream of type <: Subscribable{L} where L referes to type of data of input Observable\n\nExamples\n\nusing Rocket\n\nsource = of(\"Hello, world!\")\nsubscribe!(source |> uppercase(), logger())\n;\n\n# output\n\n[LogActor] Data: HELLO, WORLD!\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/uppercase/#See-also","page":"uppercase","title":"See also","text":"","category":"section"},{"location":"operators/transformation/uppercase/","page":"uppercase","title":"uppercase","text":"Operators, map, lowercase","category":"page"},{"location":"observables/types/file/#observable_file","page":"File","title":"File Observable","text":"","category":"section"},{"location":"observables/types/file/","page":"File","title":"File","text":"file","category":"page"},{"location":"observables/types/file/#Rocket.file","page":"File","title":"Rocket.file","text":"file(path::String)\n\nCreation operator for the SyncFileObservable with a given path.\n\nSee also: SyncFileObservable\n\n\n\n\n\n","category":"function"},{"location":"observables/types/file/","page":"File","title":"File","text":"SyncFileObservable","category":"page"},{"location":"observables/types/file/#Rocket.SyncFileObservable","page":"File","title":"Rocket.SyncFileObservable","text":"SyncFileObservable(path::String)\n\nFile observable, which synchronously emits content of the file line by line as a String objects on subscription.\n\nSee also: file, Subscribable\n\n\n\n\n\n","category":"type"},{"location":"operators/mathematical/reduce/#operator_reduce","page":"reduce","title":"Reduce Operator","text":"","category":"section"},{"location":"operators/mathematical/reduce/","page":"reduce","title":"reduce","text":"reduce","category":"page"},{"location":"operators/mathematical/reduce/#Base.reduce","page":"reduce","title":"Base.reduce","text":"reduce(::Type{R}, reduceFn::Function, seed::R) where R\nreduce(reduceFn::F) where { F <: Function }\n\nCreates a reduce operator, which applies a given accumulator reduceFn function over the source Observable, and returns the accumulated result when the source completes, given an optional seed value. If a seed value is specified, then that value will be used as the initial value for the accumulator. If no seed value is specified, the first item of the source is used as the seed.\n\nArguments\n\n::Type{R}: the type of data of transformed value\nreduceFn::Function: transformation function with (data::T, current::R) -> R signature\nseed::R: optional seed accumulation value\n\nProducing\n\nStream of type <: Subscribable{R}\n\nExamples\n\nusing Rocket\n\nsource = from([ i for i in 1:10 ])\nsubscribe!(source |> reduce(Vector{Int}, (d, c) -> [ c..., d ], Int[]), logger())\n;\n\n# output\n\n[LogActor] Data: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[LogActor] Completed\n\n\nusing Rocket\n\nsource = from([ i for i in 1:42 ])\nsubscribe!(source |> reduce(+), logger())\n;\n\n# output\n\n[LogActor] Data: 903\n[LogActor] Completed\n\n\nSee also: AbstractOperator, RightTypedOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/mathematical/reduce/#Description","page":"reduce","title":"Description","text":"","category":"section"},{"location":"operators/mathematical/reduce/","page":"reduce","title":"reduce","text":"reduce applies an accumulator function to each value of the source Observable (from the past) and reduces it to a single value that is emitted by the output Observable. Note that reduce will only emit one value, only when the source Observable completes. It is equivalent to applying scan followed by last.","category":"page"},{"location":"operators/mathematical/reduce/","page":"reduce","title":"reduce","text":"It returns an Observable that applies a specified accumulator function to each item emitted by the source Observable. If a seed value is specified, then that value will be used as the initial value of the accumulator. If no seed value is specified, the first item of the source is used as the seed.","category":"page"},{"location":"operators/mathematical/reduce/#See-also","page":"reduce","title":"See also","text":"","category":"section"},{"location":"operators/mathematical/reduce/","page":"reduce","title":"reduce","text":"Operators, scan, last","category":"page"},{"location":"operators/filtering/some/#operator_some","page":"some","title":"Some Operator","text":"","category":"section"},{"location":"operators/filtering/some/","page":"some","title":"some","text":"some","category":"page"},{"location":"operators/filtering/some/#Rocket.some","page":"some","title":"Rocket.some","text":"some()\n\nCreates a some operator, which filters out nothing items by the source Observable by emitting only those that not equal to nothing.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream <: Subscribable{Union{L, Nothing}}\n\nExamples\n\nusing Rocket\n\nsource = from([ 1, nothing, 3 ])\nsubscribe!(source |> some(), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 3\n[LogActor] Completed\n\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, max, min, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/filtering/some/#Description","page":"some","title":"Description","text":"","category":"section"},{"location":"operators/filtering/some/","page":"some","title":"some","text":"This operator takes values from the source Observable and only emits those values that are not nothing.","category":"page"},{"location":"operators/filtering/some/#See-also","page":"some","title":"See also","text":"","category":"section"},{"location":"operators/filtering/some/","page":"some","title":"some","text":"Operators, filter","category":"page"},{"location":"actors/types/storage/#actor_storage","page":"Storage","title":"Storage actor","text":"","category":"section"},{"location":"actors/types/storage/","page":"Storage","title":"Storage","text":"storage","category":"page"},{"location":"actors/types/storage/#Rocket.storage","page":"Storage","title":"Rocket.storage","text":"storage(::Type{T}) where T\n\nArguments\n\n::Type{T}: Type of storage data\n\nCreation operator for the StorageActor actor.\n\nExamples\n\nusing Rocket\n\nactor = storage(Int)\nactor isa StorageActor{Int}\n\n# output\ntrue\n\nSee also: StorageActor, AbstractActor\n\n\n\n\n\n","category":"function"},{"location":"actors/types/storage/","page":"Storage","title":"Storage","text":"StorageActor","category":"page"},{"location":"actors/types/storage/#Rocket.StorageActor","page":"Storage","title":"Rocket.StorageActor","text":"StorageActor{D}() where D\n\nStorage actor provides an actor that stores a single (last) value passed to the next! callback.  It saves last incoming successful next event in the value field, throws an ErrorException on error! event and does nothing on completion event. Before any events value initialised with nothing.\n\nExamples\n\nusing Rocket\n\nsource = from(1:5)\nactor  = storage(Int)\n\nsubscribe!(source, actor)\nshow(getvalues(actor))\n\n# output\n5\n\nSee also: Actor, storage\n\n\n\n\n\n","category":"type"},{"location":"operators/multicasting/publish/#operator_publish","page":"publish","title":"Publish Operators","text":"","category":"section"},{"location":"operators/multicasting/publish/","page":"publish","title":"publish","text":"publish\npublish_behavior\npublish_replay\npublish_recent","category":"page"},{"location":"operators/multicasting/publish/#Rocket.publish","page":"publish","title":"Rocket.publish","text":"publish(; scheduler::H = AsapScheduler()) where { H <: AbstractScheduler }\n\npublish() is a shortcut for multicast(SubjectFactory())\n\nSee also: AbstractOperator, multicast, SubjectFactory\n\n\n\n\n\n","category":"function"},{"location":"operators/multicasting/publish/#Rocket.publish_behavior","page":"publish","title":"Rocket.publish_behavior","text":"publish_behavior(default; scheduler::H = AsapScheduler()) where { H <: AbstractScheduler }\n\npublish_behavior(default) is a shortcut for multicast(BehaviorSubjectFactory(default))\n\nSee also: AbstractOperator, multicast, BehaviorSubjectFactory\n\n\n\n\n\n","category":"function"},{"location":"operators/multicasting/publish/#Rocket.publish_replay","page":"publish","title":"Rocket.publish_replay","text":"publish_replay(size::Int; scheduler::H = AsapScheduler()) where { H <: AbstractScheduler }\n\npublish_replay(size) is a shortcut for multicast(ReplaySubjectFactory(size))\n\nSee also: AbstractOperator, multicast, ReplaySubjectFactory\n\n\n\n\n\n","category":"function"},{"location":"operators/multicasting/publish/#Rocket.publish_recent","page":"publish","title":"Rocket.publish_recent","text":"publish_recent(; scheduler::H = AsapScheduler()) where { H <: AbstractScheduler }\n\npublish_recent(size) is a shortcut for multicast(RecentSubjectFactory())\n\nSee also: AbstractOperator, multicast, RecentSubjectFactory\n\n\n\n\n\n","category":"function"},{"location":"operators/multicasting/publish/#See-also","page":"publish","title":"See also","text":"","category":"section"},{"location":"operators/multicasting/publish/","page":"publish","title":"publish","text":"Operators","category":"page"},{"location":"#Rocket.jl-Documentation","page":"Home","title":"Rocket.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for Rocket.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This documentation is an adaptation of the RxJS library documentation.","category":"page"},{"location":"#Table-of-Contents","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n  \"getting-started.md\",\n  \"observables/about.md\",\n  \"actors/about.md\",\n  \"teardown/about.md\",\n  \"operators/about.md\",\n  \"operators/piping.md\",\n  \"operators/create-new-operator.md\",\n  \"operators/high-order.md\",\n  \"todo.md\",\n  \"contributing.md\",\n  \"utils.md\"\n]\nDepth = 2","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"actors/types/logger/#actor_logger","page":"Logger","title":"Logger actor","text":"","category":"section"},{"location":"actors/types/logger/","page":"Logger","title":"Logger","text":"logger","category":"page"},{"location":"actors/types/logger/#Rocket.logger","page":"Logger","title":"Rocket.logger","text":"logger([ io::IO ], name::String = \"LogActor\")\nlogger(::Type{T}, [ io::IO ], name::String = \"LogActor\") where T\n\nCreation operator for the LoggerActor actor.\n\nExamples\n\nusing Rocket\n\nsource = from([ 0, 1, 2 ])\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Completed\n\nusing Rocket\n\nsource = from([ 0, 1, 2 ])\nsubscribe!(source, logger(\"CustomName\"))\n;\n\n# output\n\n[CustomName] Data: 0\n[CustomName] Data: 1\n[CustomName] Data: 2\n[CustomName] Completed\n\nusing Rocket\n\nbuffer = IOBuffer()\n\nsource = from([ 0, 1, 2 ])\nsubscribe!(source, logger(buffer, \"CustomBuffer\"))\n;\n\nprint(String(take!(buffer)))\n# output\n\n[CustomBuffer] Data: 0\n[CustomBuffer] Data: 1\n[CustomBuffer] Data: 2\n[CustomBuffer] Completed\n\nSee also: LoggerActor, AbstractActor\n\n\n\n\n\n","category":"function"},{"location":"actors/types/logger/","page":"Logger","title":"Logger","text":"LoggerActor","category":"page"},{"location":"actors/types/logger/#Rocket.LoggerActor","page":"Logger","title":"Rocket.LoggerActor","text":"LoggerActor{D}(name::String = \"LogActor\", io::O) where { D, O }\n\nThe LoggerActor logs all next!/error!/complete! events that are sent from an Observable.\n\nConstructor arguments\n\nname: name of the logger. Optional. Default is LogActor.\nio: io stream to log in, maybe nothing to write to stdout\n\nSee also: Actor, logger\n\n\n\n\n\n","category":"type"},{"location":"operators/multicasting/about/#Multicasting-category","page":"About multicasting operators","title":"Multicasting category","text":"","category":"section"},{"location":"operators/multicasting/about/","page":"About multicasting operators","title":"About multicasting operators","text":"There are operators for different purposes, and they may be categorized as: creation, transformation, filtering, joining, multicasting, error handling, utility, etc. In the following list you will find all the operators organized in multicasting category.","category":"page"},{"location":"operators/multicasting/about/","page":"About multicasting operators","title":"About multicasting operators","text":"multicast\npublish\npublish_behavior\npublish_replay\nshare\nshare_replay","category":"page"},{"location":"operators/multicasting/about/#See-also","page":"About multicasting operators","title":"See also","text":"","category":"section"},{"location":"operators/multicasting/about/","page":"About multicasting operators","title":"About multicasting operators","text":"Operators","category":"page"},{"location":"observables/types/zipped/#observable_zipped","page":"Zipped","title":"Zipped Observable","text":"","category":"section"},{"location":"observables/types/zipped/","page":"Zipped","title":"Zipped","text":"zipped","category":"page"},{"location":"observables/types/zipped/#Rocket.zipped","page":"Zipped","title":"Rocket.zipped","text":"zipped(sources...)\n\nCombines multiple Observables to create an Observable whose values are calculated from the values, in order, of each of its input Observables.\n\nArguments\n\nsources: input sources\n\nExamples\n\nusing Rocket\n\nsource = zipped(of(1), from(2:5))\n\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: (1, 2)\n[LogActor] Completed\n\nusing Rocket\n\nsource = zipped(from(1:3), from(1:5))\n\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: (1, 1)\n[LogActor] Data: (2, 2)\n[LogActor] Data: (3, 3)\n[LogActor] Completed\n\nusing Rocket\n\nsource = zipped(completed(), of(0.0))\n\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Completed\n\nSee also: Subscribable, subscribe!\n\n\n\n\n\n","category":"function"},{"location":"contributing/#Contribution-guidelines","page":"Contributing","title":"Contribution guidelines","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"We welcome all possible contributors. This page details the some of the guidelines that should be followed when contributing to this package.","category":"page"},{"location":"contributing/#Reporting-bugs","page":"Contributing","title":"Reporting bugs","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"We track bugs using GitHub issues. We encourage you to write complete, specific, reproducible bug reports. Mention the versions of Julia and Rocket.jl for which you observe unexpected behavior. Please provide a concise description of the problem and complement it with code snippets, test cases, screenshots, tracebacks or any other information that you consider relevant. This will help us to replicate the problem and narrow the search space for solutions.","category":"page"},{"location":"contributing/#Suggesting-features","page":"Contributing","title":"Suggesting features","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"We welcome new feature proposals. However, before submitting a feature request, consider a few things:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Does the feature require changes in the core Rocket.jl code? If it doesn't (for example, you would like to add a operator for a particular application), consider making a separate repository for your extensions.\nIf you would like to add an implementation of a feature that changes a lot in the core Rocket.jl code, please open an issue on GitHub and describe your proposal first. This will allow us to discuss your proposal with you before you invest your time in implementing something that may be difficult to merge later on.","category":"page"},{"location":"contributing/#Contributing-code","page":"Contributing","title":"Contributing code","text":"","category":"section"},{"location":"contributing/#Installing-Rocket","page":"Contributing","title":"Installing Rocket","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"We suggest that you use the dev command from the new Julia package manager to install Rocket.jl for development purposes. To work on your fork of Rocket.jl, use your fork's URL address in the dev command, for example:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"] dev git@github.com:your_username/Rocket.jl.git","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The dev command clones Rocket.jl to ~/.julia/dev/Rocket. All local changes to Rocket code will be reflected in imported code.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nIt is also might be useful to install Revise.jl package as it allows you to modify code and use the changes without restarting Julia.","category":"page"},{"location":"contributing/#Committing-code","page":"Contributing","title":"Committing code","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"We use the standard GitHub Flow workflow where all contributions are added through pull requests. In order to contribute, first fork the repository, then commit your contributions to your fork, and then create a pull request on the master branch of the Rocket.jl repository.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Before opening a pull request, please make sure that all tests pass without failing! All demos (can be found in /demo/ directory) have to run without errors as well.","category":"page"},{"location":"contributing/#Style-conventions","page":"Contributing","title":"Style conventions","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"We use default Julia style guide. We list here a few important points and our modifications to the Julia style guide:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Use 4 spaces for indentation\nType names use UpperCamelCase. For example: ArrayObservable, MapOperator, etc..\nFunction names are lowercase with underscores, when necessary. For example: next!, subscribe!, as_actor, etc..\nVariable names and function arguments use snake_case\nThe name of a method that modifies its argument(s) must end in !","category":"page"},{"location":"contributing/#Unit-tests","page":"Contributing","title":"Unit tests","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"We use the test-driven development (TDD) methodology for Rocket.jl development. The test coverage should be as complete as possible. Please make sure that you write tests for each piece of code that you want to add.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"All unit tests are located in the /test/ directory. The /test/ directory follows the structure of the /src/ directory. Each test file should have following filename format: test_*.jl. Some tests are also present in jldoctest docs annotations directly in the source code. See Julia's documentation about doctests.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The tests can be evaluated by running following command in the Julia REPL:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"] test Rocket","category":"page"},{"location":"operators/transformation/override/#operator_override","page":"override","title":"Override Operator","text":"","category":"section"},{"location":"operators/transformation/override/","page":"override","title":"override","text":"override\nOverrideHandler","category":"page"},{"location":"operators/transformation/override/#Rocket.override","page":"override","title":"Rocket.override","text":"override(handler::OverrideHandler)\n\nCreates an override operator that overrides each emission from source observable with value  provided in handler. If handler contains nothing source observable emits as usual. For constant override see map_to. Use Rocket.setvalue! to set new value for handler.\n\nProducing\n\nStream of type <: Subscribable{Union{L, T}} where L refers to the type of source stream and T referes to the type of handler's value\n\nExamples\n\nusing Rocket \n\nsubject = Subject(Int)\nhandler = OverrideHandler(Int, -1)\n\nsource = subject |> override(handler)\n\nsubscription = subscribe!(source, logger())\n\nnext!(subject, 1)\nnext!(subject, 2)\n\nRocket.setvalue!(handler, nothing)\n\nnext!(subject, 3)\nnext!(subject, 4)\n\nRocket.setvalue!(handler, -2)\n\nnext!(subject, 5)\nnext!(subject, 6)\n\nunsubscribe!(subscription)\n\n# output\n[LogActor] Data: -1\n[LogActor] Data: -1\n[LogActor] Data: 3\n[LogActor] Data: 4\n[LogActor] Data: -2\n[LogActor] Data: -2\n\nSee also: OverrideHandler\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/override/#Rocket.OverrideHandler","page":"override","title":"Rocket.OverrideHandler","text":"OverrideHandler(::Type{T}, value::Union{Nothing, T}) where T\nOverrideHandler(::Type{T}) where T\n\nHandler used in substitute operator.\n\nSee also: substitute\n\n\n\n\n\n","category":"type"},{"location":"operators/transformation/override/#See-also","page":"override","title":"See also","text":"","category":"section"},{"location":"operators/transformation/override/","page":"override","title":"override","text":"Operators","category":"page"},{"location":"operators/filtering/find/#operator_find","page":"find","title":"Find operator","text":"","category":"section"},{"location":"operators/filtering/find/","page":"find","title":"find","text":"find","category":"page"},{"location":"operators/filtering/find/#Rocket.find","page":"find","title":"Rocket.find","text":"find(conditionFn::F) where { F <: Function }\n\nCreates a find operator, which emits only the first value emitted by the source Observable that meets some condition.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nArguments\n\nconditionFn::F: condition function with (data::T) -> Bool signature\n\nExamples\n\nusing Rocket\n\nsource = from([ 1, 2, 3, 4, 5, 6, 7, 8 ])\nsubscribe!(source |> find((d) -> d % 2 == 0), logger())\n;\n\n# output\n\n[LogActor] Data: 2\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/filtering/find/#Description","page":"find","title":"Description","text":"","category":"section"},{"location":"operators/filtering/find/","page":"find","title":"find","text":"find searches for the first item in the source Observable that matches the specified condition embodied by the predicate, and returns the first occurrence in the source. Does not emit an error if a valid value is not found.","category":"page"},{"location":"operators/filtering/find/#See-also","page":"find","title":"See also","text":"","category":"section"},{"location":"operators/filtering/find/","page":"find","title":"find","text":"Operators, take","category":"page"},{"location":"operators/utility/discontinue/#operator_discontinue","page":"discontinue","title":"Discontinue Operator","text":"","category":"section"},{"location":"operators/utility/discontinue/","page":"discontinue","title":"discontinue","text":"discontinue","category":"page"},{"location":"operators/utility/discontinue/#Rocket.discontinue","page":"discontinue","title":"Rocket.discontinue","text":"discontinue()\n\nCreates an operator, which prevents an emitting of self-depending messages and breaks a possible infinite loop. Does nothing if observable scheduled asynchronously.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\ns = BehaviorSubject(0)\n\nsubscription1 = subscribe!(s, logger())\nsubscription2 = subscribe!(s |> map(Int, d -> d + 1) |> discontinue(), s)\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Data: 1\n\nSee also: AbstractOperator, RightTypedOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/discontinue/#See-also","page":"discontinue","title":"See also","text":"","category":"section"},{"location":"operators/utility/discontinue/","page":"discontinue","title":"discontinue","text":"Operators","category":"page"},{"location":"teardown/about/#section_subscription","page":"Subscription","title":"Subscription","text":"","category":"section"},{"location":"teardown/about/","page":"Subscription","title":"Subscription","text":"A Subscription represents a disposable resource, usually the execution of an Observable. A Subscription has one important method: unsubscribe!(teardown), which takes some teardown logic object as one argument and disposes the resource held by the subscription.","category":"page"},{"location":"teardown/about/","page":"Subscription","title":"Subscription","text":"using Rocket\n\nsource = Subject(Int)\n\nnext!(source, 0) # Logs nothing as there is no subscribers\n\nsubscription = subscribe!(source, logger())\n\nnext!(source, 1) # Logs [LogActor] Data: 1 into standard output\n\nunsubscribe!(subscription)\n\nnext!(source, 2) # Logs nothing as a single one actor has unsubscribed","category":"page"},{"location":"teardown/about/","page":"Subscription","title":"Subscription","text":"note: Note\nA Subscription essentially just has its own specific method for unsubscribe!() function which releases resources or cancel Observable executions. Any Observable has to return a valid Teardown object.","category":"page"},{"location":"teardown/about/","page":"Subscription","title":"Subscription","text":"unsubscribe! function also supports multiple unsubscriptions at once. If the input argument to the unsubscribe! function is either a tuple or a vector, it will first check that all of the arguments are valid subscription objects and if its true will unsubscribe from each of them individually.","category":"page"},{"location":"teardown/about/","page":"Subscription","title":"Subscription","text":"\nsource = Subject(Int)\n\nsubscription1 = subscribe!(source, logger())\nsubscription2 = subscribe!(source, logger())\n\nunsubscribe!((subscription1, subscription2))\n\n# or similarly\n# unsubscribe!([ subscription1, subscription2 ])\n","category":"page"},{"location":"teardown/about/","page":"Subscription","title":"Subscription","text":"For more information about subscription and teardown logic see the API Section","category":"page"},{"location":"operators/transformation/switch_map_to/#operator_switch_map_to","page":"switch_map_to","title":"SwitchMapTo Operator","text":"","category":"section"},{"location":"operators/transformation/switch_map_to/","page":"switch_map_to","title":"switch_map_to","text":"switch_map_to","category":"page"},{"location":"operators/transformation/switch_map_to/#Rocket.switch_map_to","page":"switch_map_to","title":"Rocket.switch_map_to","text":"switch_map_to(inner_observable)\n\nCreates a switch_map_to operator, which projects each source value to the same Observable which is flattened multiple times with switch_map in the output Observable.\n\nArguments\n\ninner_observable: an Observable to replace each value from the source Observable.\n\nProducing\n\nStream of type <: Subscribable{R} where R refers to the eltype of inner_observable\n\nExamples\n\nusing Rocket\n\nsource = from([ 0, 0, 0 ])\nsubscribe!(source |> switch_map_to(from([ 1, 2, 3 ])), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Completed\n\nSee also: switch_map, AbstractOperator, RightTypedOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/switch_map_to/","page":"switch_map_to","title":"switch_map_to","text":"note: Note\nswitch_map_to is equivalent to switch_map with mappingFn set to (_) -> inner_observable.","category":"page"},{"location":"operators/transformation/switch_map_to/#See-also","page":"switch_map_to","title":"See also","text":"","category":"section"},{"location":"operators/transformation/switch_map_to/","page":"switch_map_to","title":"switch_map_to","text":"Operators","category":"page"},{"location":"operators/errors/rerun/#operator_rerun","page":"rerun","title":"Rerun Operator","text":"","category":"section"},{"location":"operators/errors/rerun/","page":"rerun","title":"rerun","text":"rerun","category":"page"},{"location":"operators/errors/rerun/#Rocket.rerun","page":"rerun","title":"Rocket.rerun","text":"rerun(count::Int = -1)\n\nReturns an Observable that mirrors the source Observable with the exception of an error. If the source Observable calls error, this method will resubscribe to the source Observable for a maximum of count resubscriptions (given as a number parameter) rather than propagating the error call.\n\nArguments:\n\ncount::Int: Number of retry attempts before failing. Optional. Default is -1.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource = from(1:3) |> safe() |> map(Int, (d) -> d > 1 ? error(\"Error\") : d) |> rerun(3)\n\nsubscribe!(source, logger())\n;\n\n# output\n[LogActor] Data: 1\n[LogActor] Data: 1\n[LogActor] Data: 1\n[LogActor] Data: 1\n[LogActor] Error: ErrorException(\"Error\")\n\nSee also: AbstractOperator, InferableOperator, catch_error, logger, safe\n\n\n\n\n\n","category":"function"},{"location":"operators/errors/rerun/#Description","page":"rerun","title":"Description","text":"","category":"section"},{"location":"operators/errors/rerun/","page":"rerun","title":"rerun","text":"Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications would be: [1, 2, 1, 2, 3, 4, 5, complete].","category":"page"},{"location":"operators/errors/rerun/#See-also","page":"rerun","title":"See also","text":"","category":"section"},{"location":"operators/errors/rerun/","page":"rerun","title":"rerun","text":"Operators","category":"page"},{"location":"observables/types/timer/#observable_timer","page":"Timer","title":"Timer Observable","text":"","category":"section"},{"location":"observables/types/timer/","page":"Timer","title":"Timer","text":"timer","category":"page"},{"location":"observables/types/timer/#Rocket.timer","page":"Timer","title":"Rocket.timer","text":"timer(delay::Int)\ntimer(delay::Int, period::Int)\n\nCreation operator for the TimerObservable. Its like interval(@ref), but you can specify when should the emissions start. timer returns an Observable that emits an infinite sequence of ascending integers, with a constant interval of time, period of your choosing between those emissions. The first emission happens after the specified delay. If period is not specified, the output Observable emits only one value, 0. Otherwise, it emits an infinite sequence.\n\nArguments\n\ndelay: the initial delay time specified as an integer denoting milliseconds to wait before emitting the first value of 0.\nperiod: the minimum period of time between emissions of the subsequent numbers (in milliseconds).\n\nExamples\n\nusing Rocket\n\nsource = timer(0, 50)\n\nsleep(0.075)\nsubscription = subscribe!(source, logger())\nsleep(0.105)\nunsubscribe!(subscription)\n\nclose(source)\n;\n\n# output\n\n[LogActor] Data: 2\n[LogActor] Data: 3\n\n\nSee also: interval, TimerObservable, subscribe!, logger\n\n\n\n\n\n","category":"function"},{"location":"observables/types/timer/","page":"Timer","title":"Timer","text":"TimerObservable","category":"page"},{"location":"observables/types/timer/#Rocket.TimerObservable","page":"Timer","title":"Rocket.TimerObservable","text":"TimerObservable\n\nAn Observable that starts emitting after an delay and emits ever increasing numbers after each period of time thereafter.\n\nParameters\n\ndelay: The initial delay time specified as an integer denoting milliseconds to wait before emitting the first value of 0`.\nperiod: The minimum period of time in milliseconds between emissions of the subsequent numbers.\n\nSee also: timer, Subscribable\n\n\n\n\n\n","category":"type"},{"location":"actors/about/#section_actors","page":"Actor","title":"Actors","text":"","category":"section"},{"location":"actors/about/","page":"Actor","title":"Actor","text":"An Actor is the most primitive unit of computation: it receives a message and performs a computation.","category":"page"},{"location":"actors/about/","page":"Actor","title":"Actor","text":"An actor is analogous to an object in an object-oriented languages. An object receives a message (a method call) and does something depending on which message it receives (the method we are calling). The main difference is that actors are completely isolated from each other, and they will never share memory. It’s also worth mentioning that an actor can maintain a private state that should never be changed directly by another actor.","category":"page"},{"location":"actors/about/","page":"Actor","title":"Actor","text":"For a quick introduction to Actor models, see this article.","category":"page"},{"location":"actors/about/","page":"Actor","title":"Actor","text":"The API of Rocket.jl's Actors is similar to RxJS subscribers.","category":"page"},{"location":"actors/about/#First-example","page":"Actor","title":"First example","text":"","category":"section"},{"location":"actors/about/","page":"Actor","title":"Actor","text":"The following example implements an Actor that retains each received value from an Observable.","category":"page"},{"location":"actors/about/","page":"Actor","title":"Actor","text":"using Rocket\n\nstruct CustomKeepActor <: Actor{Int}\n    values::Vector{Int}\n\n    CustomKeepActor() = new(Vector{Int}())\nend\n\nRocket.on_next!(actor::CustomKeepActor, data::Int) = push!(actor.values, data)\nRocket.on_error!(actor::CustomKeepActor, err)      = error(err)\nRocket.on_complete!(actor::CustomKeepActor)        = println(\"Completed!\")\n\nsource     = from([ 1, 2, 3 ])\nkeep_actor = CustomKeepActor()\nsubscribe!(source, keep_actor)\n\n# Logs\n# Completed!\n\nprintln(keep_actor.values)\n\n# Logs\n# [1, 2, 3]","category":"page"},{"location":"actors/about/","page":"Actor","title":"Actor","text":"An actor may be not interested in the values itself, but merely the completion of an event. In this case, Rocket.jl provides a CompletionActor abstract type. See also NextActor and ErrorActor.","category":"page"},{"location":"actors/about/","page":"Actor","title":"Actor","text":"using Rocket\n\nstruct CompletionNotificationActor <: CompletionActor{Int} end\n\nRocket.on_complete!(::CompletionNotificationActor) = println(\"Completed!\")\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source, CompletionNotificationActor());\n\n# Logs\n# Completed","category":"page"},{"location":"actors/about/","page":"Actor","title":"Actor","text":"It is also possible to use Julia's multiple dispatch feature and dispatch on type of the event","category":"page"},{"location":"actors/about/","page":"Actor","title":"Actor","text":"using Rocket\n\nstruct MyCustomActor <: NextActor{Any} end\n\nRocket.on_next!(::MyCustomActor, data::Int)     = println(\"Int: $data\")\nRocket.on_next!(::MyCustomActor, data::Float64) = println(\"Float64: $data\")\nRocket.on_next!(::MyCustomActor, data)          = println(\"Something else: $data\")\n\nsource = from([ 1, 1.0, \"string\" ])\nsubscribe!(source, MyCustomActor());\n\n# Logs\n# Int: 1\n# Float64: 1.0\n# Something else: string\n","category":"page"},{"location":"actors/about/#Lambda-actor","page":"Actor","title":"Lambda actor","text":"","category":"section"},{"location":"actors/about/","page":"Actor","title":"Actor","text":"For debugging purposes it may be convenient to work with a LambdaActor. This provides an interface that defines callbacks for \"next\", \"error\" and \"complete\" events. But this generic actor does not allow to dispatch on type of the event.","category":"page"},{"location":"actors/about/","page":"Actor","title":"Actor","text":"using Rocket\n\nsource = from([1, 2, 3])\n\nsubscribe!(source, lambda(\n    on_next     = (d) -> println(d),\n    on_error    = (e) -> error(e),\n    on_complete = ()  -> println(\"Completed\")\n))\n\n# Logs\n# 1\n# 2\n# 3\n# Completed","category":"page"},{"location":"actors/about/#Function-actor","page":"Actor","title":"Function actor","text":"","category":"section"},{"location":"actors/about/","page":"Actor","title":"Actor","text":"Sometimes it is convenient to pass only on_next callback. Rocket.jl provides a FunctionActor which automatically converts any function object passed in the subscribe! function to a proper actor which listens only for data events, throws an exception on error event and ignores completion message.","category":"page"},{"location":"actors/about/","page":"Actor","title":"Actor","text":"using Rocket\n\nsource = from([1, 2, 3])\n\nsubscribe!(source, (d) -> println(d))\n\n# Logs\n# 1\n# 2\n# 3","category":"page"},{"location":"observables/types/single/#observable_single","page":"Single","title":"Single Observable","text":"","category":"section"},{"location":"observables/types/single/","page":"Single","title":"Single","text":"of","category":"page"},{"location":"observables/types/single/#Rocket.of","page":"Single","title":"Rocket.of","text":"of(x; scheduler::H = AsapScheduler()) where { H <: AbstractScheduler }\n\nCreation operator for the SingleObservable that emits a single value x and then completes.\n\nArguments\n\nx: value to be emmited before completion\n\nExamples\n\nusing Rocket\n\nsource = of(1)\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Completed\n\n\nSee also: SingleObservable, subscribe!, logger\n\n\n\n\n\n","category":"function"},{"location":"observables/types/single/","page":"Single","title":"Single","text":"SingleObservable","category":"page"},{"location":"observables/types/single/#Rocket.SingleObservable","page":"Single","title":"Rocket.SingleObservable","text":"SingleObservable{D, H}(value::D, scheduler::H)\n\nSingleObservable wraps single value of type D into a observable.\n\nConstructor arguments\n\nvalue: a single value to emit\nscheduler: scheduler-like object\n\nSee also: of, Subscribable\n\n\n\n\n\n","category":"type"},{"location":"observables/types/interval/#observable_interval","page":"Interval","title":"Interval Observable","text":"","category":"section"},{"location":"observables/types/interval/","page":"Interval","title":"Interval","text":"interval","category":"page"},{"location":"observables/types/interval/#Rocket.interval","page":"Interval","title":"Rocket.interval","text":"interval(period::Union{Int, Nothing} = nothing)\n\nCreation operator for the TimerObservable. interval returns an Observable that emits an infinite sequence of ascending integers, with a constant interval of time of your choosing between those emissions. The first emission is not sent immediately, but only after the first period has passed.\n\nArguments\n\ninterval: the interval size in milliseconds\n\nExamples\n\nusing Rocket\n\nsource = interval(50)\n\nsubscription = subscribe!(source, logger())\nsleep(0.215)\nunsubscribe!(subscription)\nsleep(0.215)\nsubscription = subscribe!(source, logger())\nsleep(0.185)\nunsubscribe!(subscription)\n\nclose(source)\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Data: 8\n[LogActor] Data: 9\n[LogActor] Data: 10\n\nSee also: timer, TimerObservable, Subscribable\n\n\n\n\n\n","category":"function"},{"location":"operators/filtering/take_until/#operator_take_until","page":"take_until","title":"TakeUntil Operator","text":"","category":"section"},{"location":"operators/filtering/take_until/","page":"take_until","title":"take_until","text":"take_until","category":"page"},{"location":"operators/filtering/take_until/#Rocket.take_until","page":"take_until","title":"Rocket.take_until","text":"take_until(notifier::S)\n\nCreates a take operator, which returns an Observable that emits the values emitted by the source Observable until a notifier Observable emits a value or a completion event.\n\nArguments\n\nnotifier::S: The Observable whose first emitted value will cause the output Observable of take_until to stop emitting values from the source Observable.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource = interval(100) |> take_until(timer(1000))\n\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Data: 4\n[LogActor] Data: 5\n[LogActor] Data: 6\n[LogActor] Data: 7\n[LogActor] Data: 8\n[LogActor] Completed\n\nusing Rocket \n\nsource = interval(100)\n\nsubscribe!(source |> take_until(source |> filter(i -> i == 3)), logger())\n;\n\n# output \n\n[LogActor] Data: 0\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/filtering/take_until/#Description","page":"take_until","title":"Description","text":"","category":"section"},{"location":"operators/filtering/take_until/","page":"take_until","title":"take_until","text":"take_until subscribes and begins mirroring the source Observable. It also monitors a second Observable, notifier that you provide. If the notifier emits a value, the output Observable stops mirroring the source Observable and completes. If the notifier doesn't emit any value and completes then take_until also completes.","category":"page"},{"location":"operators/filtering/take_until/#See-also","page":"take_until","title":"See also","text":"","category":"section"},{"location":"operators/filtering/take_until/","page":"take_until","title":"take_until","text":"Operators","category":"page"},{"location":"operators/multicasting/share/#operator_share","page":"share","title":"Share Operators","text":"","category":"section"},{"location":"operators/multicasting/share/","page":"share","title":"share","text":"share\nshare_replay\nshare_recent","category":"page"},{"location":"operators/multicasting/share/#Rocket.share","page":"share","title":"Rocket.share","text":"share(; scheduler::H = AsapScheduler()) where { H <: AbstractScheduler }\n\nshare() is a shortcut for publish() + ref_count()\n\nSee also: AbstractOperator, multicast, publish, ref_count\n\n\n\n\n\n","category":"function"},{"location":"operators/multicasting/share/#Rocket.share_replay","page":"share","title":"Rocket.share_replay","text":"share_replay(size::Int; scheduler::H = AsapScheduler()) where { H <: AbstractScheduler }\n\nshare_replay(size) is a shortcut for publish_replay(size) + ref_count()\n\nSee also: AbstractOperator, multicast, publish, publish_replay, ref_count\n\n\n\n\n\n","category":"function"},{"location":"operators/multicasting/share/#Rocket.share_recent","page":"share","title":"Rocket.share_recent","text":"share_recent(; scheduler::H = AsapScheduler()) where { H <: AbstractScheduler }\n\nshare_recent() is a shortcut for publish_recent() + ref_count()\n\nSee also: AbstractOperator, multicast, publish, publish_recent, ref_count\n\n\n\n\n\n","category":"function"},{"location":"operators/multicasting/share/#See-also","page":"share","title":"See also","text":"","category":"section"},{"location":"operators/multicasting/share/","page":"share","title":"share","text":"Operators","category":"page"},{"location":"operators/transformation/concat_map/#operator_concat_map","page":"concat_map","title":"ConcatMap Operator","text":"","category":"section"},{"location":"operators/transformation/concat_map/","page":"concat_map","title":"concat_map","text":"concat_map","category":"page"},{"location":"operators/transformation/concat_map/#Rocket.concat_map","page":"concat_map","title":"Rocket.concat_map","text":"concat_map(::Type{R}, mappingFn::F = identity) where { R, F <: Function }\n\nCreates a concat_map operator, which returns an Observable that emits the result of applying the projection function to each item emitted by the source Observable and taking values from each projected inner Observable sequentially. Essentialy it projects each source value to an Observable which is merged in the output Observable, in a serialized fashion waiting for each one to complete before merging the next.\n\nArguments\n\n::Type{R}: the type of data of output Observables after projection with mappingFn\nmappingFn::F: projection function with (data) -> Observable{R} signature\n\nProducing\n\nStream of type <: Subscribable{R}\n\nExamples\n\nusing Rocket\n\nsource = from([ 0, 0 ]) |> concat_map(Int, d -> from([ 1, 2, 3 ], scheduler = AsyncScheduler(0)))\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Completed\n\nSee also: AbstractOperator, RightTypedOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/concat_map/#Description","page":"concat_map","title":"Description","text":"","category":"section"},{"location":"operators/transformation/concat_map/","page":"concat_map","title":"concat_map","text":"Returns an Observable that emits items based on applying a function that you supply to each item emitted by the source Observable, where that function returns an (so-called \"inner\") Observable. Each new inner Observable is concatenated with the previous inner Observable.","category":"page"},{"location":"operators/transformation/concat_map/","page":"concat_map","title":"concat_map","text":"warning: Warning\nIf source values arrive endlessly and faster than their corresponding inner Observables can complete, it will result in memory issues as inner Observables amass in an unbounded buffer waiting for their turn to be subscribed to.","category":"page"},{"location":"operators/transformation/concat_map/","page":"concat_map","title":"concat_map","text":"note: Note\nconcat_map is equivalent to merge_map with concurrency parameter set to 1.","category":"page"},{"location":"operators/transformation/concat_map/#See-also","page":"concat_map","title":"See also","text":"","category":"section"},{"location":"operators/transformation/concat_map/","page":"concat_map","title":"concat_map","text":"Operators, merge_map","category":"page"},{"location":"subjects/types/pending/#subject_pending","page":"Pending","title":"PendingSubject","text":"","category":"section"},{"location":"subjects/types/pending/","page":"Pending","title":"Pending","text":"PendingSubject\nPendingSubjectFactory","category":"page"},{"location":"subjects/types/pending/#Rocket.PendingSubject","page":"Pending","title":"Rocket.PendingSubject","text":"PendingSubject(::Type{D}) where D\nPendingSubject(::Type{D}, factory::F) where { D, F <: AbstractFactory }\nPendingSubject(::Type{D}, subject::S) where { D, S }\n\nA variant of Subject that emits its last value on completion. Reemits last value on further subscriptions and then completes.\n\nSee also: PendingSubjectFactory, Subject, SubjectFactory\n\n\n\n\n\n","category":"function"},{"location":"subjects/types/pending/#Rocket.PendingSubjectFactory","page":"Pending","title":"Rocket.PendingSubjectFactory","text":"PendingSubjectFactory(factory::F) where { F <: AbstractSubjectFactory }\nPendingSubjectFactory(; scheduler::H = AsapScheduler()) where { H <: AbstractScheduler }\n\nA variant of SubjectFactory that creates an instance of PendingSubject.\n\nSee also: SubjectFactory, AbstractSubjectFactory, PendingSubject, Subject\n\n\n\n\n\n","category":"function"},{"location":"subjects/types/pending/#Description","page":"Pending","title":"Description","text":"","category":"section"},{"location":"subjects/types/pending/","page":"Pending","title":"Pending","text":"A variant of Subject that only emits a value when it completes. It will emit its latest value to all its observers on completion. It will reemit its latest value to all new observers on further subscription and then complete. It is not possible to overwrite last value after completion.","category":"page"},{"location":"subjects/types/pending/#Examples","page":"Pending","title":"Examples","text":"","category":"section"},{"location":"subjects/types/pending/","page":"Pending","title":"Pending","text":"using Rocket\n\nsubject = PendingSubject(Int)\n\nsubscription1 = subscribe!(subject, logger(\"1\"))\n\nnext!(subject, 1) # Nothing is logged\nnext!(subject, 2) # Nothing is logged\n\nsubscription2 = subscribe!(subject, logger(\"2\"))\n\nnext!(subject, 3) # Nothing is logged\n\ncomplete!(subject)\n\nsubscription3 = subscribe!(subject, logger(\"3\"))\n\n[1] Data: 3\n[2] Data: 3\n[1] Completed\n[2] Completed\n[3] Data: 3\n[3] Completed","category":"page"},{"location":"operators/filtering/filter_type/#operator_filter_type","page":"filter_type","title":"FilterType Operator","text":"","category":"section"},{"location":"operators/filtering/filter_type/","page":"filter_type","title":"filter_type","text":"filter_type","category":"page"},{"location":"operators/filtering/filter_type/#Rocket.filter_type","page":"filter_type","title":"Rocket.filter_type","text":"filter_type(type::Type{ T }) where { T }\n\nCreates a filter_type operator, which filters items of the source Observable by emitting only those that match a specified T type with a <: operator. This operator is a more efficient version of filter(v -> v <: T) |> map(T, v -> v) operators chain.\n\nProducing\n\nStream of type <: Subscribable{ T } where T refers to type argument\n\nExamples\n\nusing Rocket\n\nsource = from(Real[ 1, 2.0, 3, 4.0, 5, 6.0 ])\nsubscribe!(source |> filter_type(Int), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 3\n[LogActor] Data: 5\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/filtering/filter_type/#See-also","page":"filter_type","title":"See also","text":"","category":"section"},{"location":"operators/filtering/filter_type/","page":"filter_type","title":"filter_type","text":"Operators","category":"page"},{"location":"operators/filtering/filter/#operator_filter","page":"filter","title":"Filter Operator","text":"","category":"section"},{"location":"operators/filtering/filter/","page":"filter","title":"filter","text":"filter","category":"page"},{"location":"operators/filtering/filter/#Base.filter","page":"filter","title":"Base.filter","text":"filter(filterFn::F) where { F <: Function }\n\nCreates a filter operator, which filters items of the source Observable by emitting only those that satisfy a specified filterFn predicate.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nArguments\n\nfilterFn::F: predicate function with (data::T) -> Bool signature\n\nExamples\n\nusing Rocket\n\nsource = from([ 1, 2, 3, 4, 5, 6 ])\nsubscribe!(source |> filter((d) -> d % 2 == 0), logger())\n;\n\n# output\n\n[LogActor] Data: 2\n[LogActor] Data: 4\n[LogActor] Data: 6\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/filtering/filter/#Description","page":"filter","title":"Description","text":"","category":"section"},{"location":"operators/filtering/filter/","page":"filter","title":"filter","text":"Like filter(f, array), this operator takes values from the source Observable, passes them through a predicate function and only emits those values that yielded true.","category":"page"},{"location":"operators/filtering/filter/#See-also","page":"filter","title":"See also","text":"","category":"section"},{"location":"operators/filtering/filter/","page":"filter","title":"filter","text":"Operators","category":"page"},{"location":"operators/join/with_latest/#operator_with_latest","page":"with_latest","title":"WithLatest Operator","text":"","category":"section"},{"location":"operators/join/with_latest/","page":"with_latest","title":"with_latest","text":"with_latest","category":"page"},{"location":"operators/join/with_latest/#Rocket.with_latest","page":"with_latest","title":"Rocket.with_latest","text":"with_latest(sources...)\n\nCreates a with_latest operator, which combines the source Observable with other Observables to create an Observable whose values are calculated from the latest values of each, only when the source emits.\n\nExamples\n\nusing Rocket\n\nsource = of(1)\nsubscribe!(source |> with_latest(from(1:5)), logger())\n;\n\n# output\n\n[LogActor] Data: (1, 5)\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator\n\n\n\n\n\n","category":"function"},{"location":"operators/join/with_latest/#See-also","page":"with_latest","title":"See also","text":"","category":"section"},{"location":"operators/join/with_latest/","page":"with_latest","title":"with_latest","text":"Operators","category":"page"},{"location":"operators/join/about/#Join-category","page":"Join category","title":"Join category","text":"","category":"section"},{"location":"operators/join/about/","page":"Join category","title":"Join category","text":"There are operators for different purposes, and they may be categorized as: creation, transformation, filtering, joining, multicasting, error handling, utility, etc. In the following list you will find all the operators organized in join category.","category":"page"},{"location":"operators/join/about/","page":"Join category","title":"Join category","text":"with_latest","category":"page"},{"location":"operators/join/about/#See-also","page":"Join category","title":"See also","text":"","category":"section"},{"location":"operators/join/about/","page":"Join category","title":"Join category","text":"Operators","category":"page"},{"location":"subjects/types/behavior/#subject_behavior","page":"Behavior","title":"BehaviorSubject","text":"","category":"section"},{"location":"subjects/types/behavior/","page":"Behavior","title":"Behavior","text":"BehaviorSubject\nBehaviorSubjectFactory","category":"page"},{"location":"subjects/types/behavior/#Rocket.BehaviorSubject","page":"Behavior","title":"Rocket.BehaviorSubject","text":"BehaviorSubject(value::D) where D\nBehaviorSubject(::Type{D}, value) where D\nBehaviorSubject(::Type{D}, value, factory::F) where { D, F <: AbstractSubjectFactory }\nBehaviorSubject(::Type{D}, value, subject::S) where { D, S }\n\nA variant of Subject that requires an initial value and emits its current value whenever it is subscribed to.\n\nSee also: BehaviorSubjectFactory, Subject, SubjectFactory\n\n\n\n\n\n","category":"function"},{"location":"subjects/types/behavior/#Rocket.BehaviorSubjectFactory","page":"Behavior","title":"Rocket.BehaviorSubjectFactory","text":"BehaviorSubjectFactory(default, factory::F) where { F <: AbstractSubjectFactory }\nBehaviorSubjectFactory(default; scheduler::H = AsapScheduler()) where { H <: AbstractScheduler }\n\nA variant of SubjectFactory that creates an instance of ReplaySubject.\n\nSee also: SubjectFactory, AbstractSubjectFactory, BehaviorSubject, Subject\n\n\n\n\n\n","category":"function"},{"location":"subjects/types/behavior/#Description","page":"Behavior","title":"Description","text":"","category":"section"},{"location":"subjects/types/behavior/","page":"Behavior","title":"Behavior","text":"One of the variants of Subjects is the BehaviorSubject, which has a notion of \"the current value\". It stores the latest value emitted to its consumers, and whenever a new Observer subscribes, it will immediately receive the \"current value\" from the BehaviorSubject.","category":"page"},{"location":"subjects/types/behavior/","page":"Behavior","title":"Behavior","text":"note: Note\nBehaviorSubjects are useful for representing \"values over time\". For instance, an event stream of birthdays is a Subject, but the stream of a person's age would be a BehaviorSubject.","category":"page"},{"location":"subjects/types/behavior/#Examples","page":"Behavior","title":"Examples","text":"","category":"section"},{"location":"subjects/types/behavior/","page":"Behavior","title":"Behavior","text":"In the following example, the BehaviorSubject is initialized with the value 0 which the first Observer receives when it subscribes. The second Observer receives the value 2 even though it subscribed after the value 2 was sent.","category":"page"},{"location":"subjects/types/behavior/","page":"Behavior","title":"Behavior","text":"using Rocket\n\nsubject = BehaviorSubject(Int, 0)\n\nsubscription1 = subscribe!(subject, logger(\"1\"))\n\nnext!(subject, 1)\nnext!(subject, 2)\n\nsubscription2 = subscribe!(subject, logger(\"2\"))\n\nnext!(subject, 3)\n\nunsubscribe!(subscription1)\nunsubscribe!(subscription2)\n\n// Logs\n// [1] Data: 0\n// [1] Data: 1\n// [1] Data: 2\n// [2] Data: 2\n// [1] Data: 3\n// [2] Data: 3","category":"page"},{"location":"api/operators/#operators_api","page":"Operators","title":"Operators API","text":"","category":"section"},{"location":"api/operators/#How-to-create-a-custom-operator","page":"Operators","title":"How to create a custom operator","text":"","category":"section"},{"location":"api/operators/","page":"Operators","title":"Operators","text":"If you need to write an operator that cannot be made from a combination of existing operators, then you can write a custom operator from scratch.","category":"page"},{"location":"api/operators/","page":"Operators","title":"Operators","text":"Each operator (e.g. MyFancyOperator) needs to either be (1) a subtype of one of abstract OperatorTrait trait types, or (2) define a","category":"page"},{"location":"api/operators/","page":"Operators","title":"Operators","text":"Rocket.as_operator(::Type{<:MyFancyOperator}) = TypedOperatorTrait{T, R}()\n# or\nRocket.as_operator(::Type{<:MyFancyOperator}) = InferableOperatorTrait()","category":"page"},{"location":"api/operators/","page":"Operators","title":"Operators","text":"trait behavior.","category":"page"},{"location":"api/operators/","page":"Operators","title":"Operators","text":"In addition, an operator must implement a specific method for on_call! function with custom logic which has to return another Observable as a result of applying MyFancyOperator to a source.","category":"page"},{"location":"api/operators/","page":"Operators","title":"Operators","text":"Rocket.on_call!(::Type{L}, ::Type{R}, operator::MyFancyOperator, source) where L = # some custom logic here\n\n# or\n# for inferable trait types you have to specify 'right' type with Rocket.operator_right which should specify a type of data of produced Observable\n\nRocket.on_call(::Type{L}, ::Type{R}, operator::MyFancyOperator, source) where L = # some custom logic here\nRocket.operator_right(::MyFancyOperator, ::Type{L}) where L = R # where R should be an actual type, Int or even L itself e.g.\n","category":"page"},{"location":"api/operators/","page":"Operators","title":"Operators","text":"note: Note\nIt is not allowed to modify the source Observable in any way; you have to return a new observable.","category":"page"},{"location":"api/operators/","page":"Operators","title":"Operators","text":"See more examples on custom operators in Traits API section","category":"page"},{"location":"api/operators/","page":"Operators","title":"Operators","text":"note: Note\nIt might be useful to return a ProxyObservable from an on_call! function. ProxyObservable is a special Observable which proxying actors with the source and/or source with actors.","category":"page"},{"location":"api/operators/#operators_api_traits","page":"Operators","title":"Traits","text":"","category":"section"},{"location":"api/operators/","page":"Operators","title":"Operators","text":"OperatorTrait\nas_operator\nTypedOperatorTrait\nLeftTypedOperatorTrait\nRightTypedOperatorTrait\nInferableOperatorTrait\nInvalidOperatorTrait","category":"page"},{"location":"api/operators/#Rocket.OperatorTrait","page":"Operators","title":"Rocket.OperatorTrait","text":"Abstract type for all possible operator traits\n\nSee also: TypedOperatorTrait, LeftTypedOperatorTrait, RightTypedOperatorTrait, InferableOperatorTrait, InvalidOperatorTrait,\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#Rocket.as_operator","page":"Operators","title":"Rocket.as_operator","text":"as_operator(any)\n\nThis function checks operator trait behavior. May be used explicitly to specify operator trait behavior for any object.\n\nSee also: OperatorTrait, AbstractOperator\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#Rocket.TypedOperatorTrait","page":"Operators","title":"Rocket.TypedOperatorTrait","text":"Typed operator trait specifies operator to be statically typed with input and output data types. Typed operator with input type L and output type R can only operate on input Observable with data type L and will always produce an Observable with data type R.\n\nExamples\n\nusing Rocket\n\nstruct MyTypedOperator <: TypedOperator{Int, Int} end\n\nfunction Rocket.on_call!(::Type{Int}, ::Type{Int}, op::MyTypedOperator, source)\n    return proxy(Int, source, MyTypedOperatorProxy())\nend\n\nstruct MyTypedOperatorProxy <: ActorProxy end\n\nRocket.actor_proxy!(::Type{Int}, ::MyTypedOperatorProxy, actor::A) where A = MyTypedOperatorProxiedActor{A}(actor)\n\nstruct MyTypedOperatorProxiedActor{A} <: Actor{Int}\n    actor :: A\nend\n\nfunction Rocket.on_next!(actor::MyTypedOperatorProxiedActor, data::Int)\n    # Do something with a data and/or redirect it to actor.actor\n    next!(actor.actor, data + 1)\nend\n\nRocket.on_error!(actor::MyTypedOperatorProxiedActor, err) = error!(actor.actor, err)\nRocket.on_complete!(actor::MyTypedOperatorProxiedActor)   = complete!(actor.actor)\n\nsource = from([ 0, 1, 2 ])\nsubscribe!(source |> MyTypedOperator(), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Completed\n\nSee also: OperatorTrait, TypedOperator, OperatorTrait, ProxyObservable, ActorProxy, logger\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#Rocket.LeftTypedOperatorTrait","page":"Operators","title":"Rocket.LeftTypedOperatorTrait","text":"Left typed operator trait specifies operator to be statically typed with input data type. To infer output data type this object should specify a special function operator_right(operator, ::Type{L}) where L which will be used to infer output data type. Left typed operator with input type L can only operate on input Observable with data type L and will always produce an Observable with data type inferred from operator_right(operator, ::Type{L}).\n\nExamples\n\nusing Rocket\n\nstruct CountIntegersOperator <: LeftTypedOperator{Int} end\n\nfunction Rocket.on_call!(::Type{Int}, ::Type{Tuple{Int, Int}}, op::CountIntegersOperator, source)\n    return proxy(Tuple{Int, Int}, source, CountIntegersOperatorProxy())\nend\n\nRocket.operator_right(::CountIntegersOperator, ::Type{Int}) = Tuple{Int, Int}\n\nstruct CountIntegersOperatorProxy <: ActorProxy end\n\nRocket.actor_proxy!(::Type{Tuple{Int, Int}}, ::CountIntegersOperatorProxy, actor::A) where A = CountIntegersProxiedActor{A}(0, actor)\n\nmutable struct CountIntegersProxiedActor{A} <: Actor{Int}\n    current :: Int\n    actor   :: A\nend\n\nfunction Rocket.on_next!(actor::CountIntegersProxiedActor, data::Int)\n    current = actor.current\n    actor.current += 1\n    next!(actor.actor, (current, data)) # e.g.\nend\n\nRocket.on_error!(actor::CountIntegersProxiedActor, err) = error!(actor.actor, err)\nRocket.on_complete!(actor::CountIntegersProxiedActor)   = complete!(actor.actor)\n\nsource = from([ 0, 0, 0 ])\nsubscribe!(source |> CountIntegersOperator(), logger())\n;\n\n# output\n\n[LogActor] Data: (0, 0)\n[LogActor] Data: (1, 0)\n[LogActor] Data: (2, 0)\n[LogActor] Completed\n\nSee also: OperatorTrait, LeftTypedOperator, operator_right, OperatorTrait, ProxyObservable, ActorProxy, enumerate, logger\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#Rocket.RightTypedOperatorTrait","page":"Operators","title":"Rocket.RightTypedOperatorTrait","text":"Right typed operator trait specifies operator to be statically typed with output data type. It can operate on input Observable with any data type L but will always produce an Observable with data type R.\n\nExamples\n\nusing Rocket\n\nstruct ConvertToFloatOperator <: RightTypedOperator{Float64} end\n\nfunction Rocket.on_call!(::Type{L}, ::Type{Float64}, op::ConvertToFloatOperator, source) where L\n    return proxy(Float64, source, ConvertToFloatProxy{L}())\nend\n\nstruct ConvertToFloatProxy{L} <: ActorProxy end\n\nfunction Rocket.actor_proxy!(::Type{Float64}, proxy::ConvertToFloatProxy{L}, actor::A) where { L, A }\n    return ConvertToFloatProxyActor{L, A}(actor)\nend\n\nstruct ConvertToFloatProxyActor{L, A} <: Actor{L}\n    actor :: A\nend\n\nfunction Rocket.on_next!(actor::ConvertToFloatProxyActor{L}, data::L) where L\n    next!(actor.actor, convert(Float64, data)) # e.g.\nend\n\nRocket.on_error!(actor::ConvertToFloatProxyActor, err) = error!(actor.actor, err)\nRocket.on_complete!(actor::ConvertToFloatProxyActor)   = complete!(actor.actor)\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> ConvertToFloatOperator(), logger())\n;\n\n# output\n\n[LogActor] Data: 1.0\n[LogActor] Data: 2.0\n[LogActor] Data: 3.0\n[LogActor] Completed\n\nSee also: OperatorTrait, RightTypedOperator, OperatorTrait, ProxyObservable, ActorProxy, logger\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#Rocket.InferableOperatorTrait","page":"Operators","title":"Rocket.InferableOperatorTrait","text":"Inferable operator trait specifies operator to be statically typed neither with input data type nor with output data type. To infer output data type this object should specify a special function operator_right(operator, ::Type{L}) where L where L is input data type which will be used to infer output data type.\n\nusing Rocket\n\nstruct IdentityOperator <: InferableOperator end\n\nfunction Rocket.on_call!(::Type{L}, ::Type{L}, op::IdentityOperator, source) where L\n    return proxy(L, source, IdentityProxy())\nend\n\nstruct IdentityProxy <: ActorProxy end\n\nRocket.operator_right(::IdentityOperator, ::Type{L}) where L = L\n\nRocket.actor_proxy!(::Type{L}, proxy::IdentityProxy, actor::A) where L where A = IdentityProxyActor{L, A}(actor)\n\nstruct IdentityProxyActor{L, A} <: Actor{L}\n    actor :: A\nend\n\nfunction Rocket.on_next!(actor::IdentityProxyActor{L}, data::L) where L\n    next!(actor.actor, data) # e.g.\nend\n\nRocket.on_error!(actor::IdentityProxyActor, err) = error!(actor.actor, err)\nRocket.on_complete!(actor::IdentityProxyActor)   = complete!(actor.actor)\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> IdentityOperator(), logger())\n\nsource = from([ 1.0, 2.0, 3.0 ])\nsubscribe!(source |> IdentityOperator(), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Completed\n[LogActor] Data: 1.0\n[LogActor] Data: 2.0\n[LogActor] Data: 3.0\n[LogActor] Completed\n\n\nSee also: OperatorTrait, InferableOperator, operator_right, OperatorTrait, ProxyObservable, ActorProxy, logger\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#Rocket.InvalidOperatorTrait","page":"Operators","title":"Rocket.InvalidOperatorTrait","text":"InvalidOperatorTrait trait specifies special 'invalid' behavior and types with such a trait specification cannot be used as an operator for an observable stream. By default any type has InvalidOperatorTrait trait specification\n\nSee also: OperatorTrait\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#Types","page":"Operators","title":"Types","text":"","category":"section"},{"location":"api/operators/","page":"Operators","title":"Operators","text":"AbstractOperator\nTypedOperator\nLeftTypedOperator\nRightTypedOperator\nInferableOperator\non_call!\noperator_right\nOperatorsComposition","category":"page"},{"location":"api/operators/#Rocket.AbstractOperator","page":"Operators","title":"Rocket.AbstractOperator","text":"Supertype for all operators\n\nSee also: TypedOperator, LeftTypedOperator, RightTypedOperator, InferableOperator\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#Rocket.TypedOperator","page":"Operators","title":"Rocket.TypedOperator","text":"Can be used as a supertype for any operator. Automatically specifies TypedOperatorTrait behavior.\n\nExamples\n\nusing Rocket\n\nstruct MyOperator <: TypedOperator{Float64,String} end\n\nas_operator(MyOperator) === TypedOperatorTrait{Float64,String}()\n\n# output\ntrue\n\nSee also: AbstractOperator, TypedOperatorTrait\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#Rocket.LeftTypedOperator","page":"Operators","title":"Rocket.LeftTypedOperator","text":"Can be used as a supertype for any operator. Automatically specifies LeftTypedOperatorTrait behavior.\n\nExamples\n\nusing Rocket\n\nstruct MyOperator <: LeftTypedOperator{Float64} end\n\nas_operator(MyOperator) === LeftTypedOperatorTrait{Float64}()\n\n# output\ntrue\n\nSee also: AbstractOperator, LeftTypedOperatorTrait, operator_right\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#Rocket.RightTypedOperator","page":"Operators","title":"Rocket.RightTypedOperator","text":"Can be used as a supertype for any operator. Automatically specifies RightTypedOperatorTrait behavior.\n\nExamples\n\nusing Rocket\n\nstruct MyOperator <: RightTypedOperator{Float64} end\n\nas_operator(MyOperator) === RightTypedOperatorTrait{Float64}()\n\n# output\ntrue\n\nSee also: AbstractOperator, RightTypedOperatorTrait\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#Rocket.InferableOperator","page":"Operators","title":"Rocket.InferableOperator","text":"Can be used as a supertype for any operator. Automatically specifies InferableOperatorTrait behavior.\n\nExamples\n\nusing Rocket\n\nstruct MyOperator <: InferableOperator end\n\nas_operator(MyOperator) === InferableOperatorTrait()\n\n# output\ntrue\n\nSee also: AbstractOperator, InferableOperatorTrait, operator_right\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#Rocket.on_call!","page":"Operators","title":"Rocket.on_call!","text":"on_call!(::Type, ::Type, operator, source)\n\nEach operator must implement its own method for on_call! function. This function is used to invoke operator on some Observable and to produce another Observable with new logic (operator specific).\n\nSee also: AbstractOperator\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#Rocket.operator_right","page":"Operators","title":"Rocket.operator_right","text":"operator_right(operator, L)\n\nBoth LeftTypedOperator and InferableOperator must implement its own method for operator_right function. This function is used to infer type of data of output Observable given the type of data of input Observable.\n\nSee also: AbstractOperator, LeftTypedOperator, InferableOperator\n\n\n\n\n\n","category":"function"},{"location":"api/operators/#Rocket.OperatorsComposition","page":"Operators","title":"Rocket.OperatorsComposition","text":"OperatorsComposition(operators)\n\nOperatorsComposition is an object which helps to create a composition of multiple operators. To create a composition of two or more operators overloaded + or |> can be used.\n\nusing Rocket\n\ncomposition = map(Int, (d) -> d ^ 2) + filter(d -> d % 2 == 0)\n\nsource = from(1:5) |> composition\n\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 4\n[LogActor] Data: 16\n[LogActor] Completed\n\nusing Rocket\n\ncomposition = map(Int, (d) -> d ^ 2) |> filter(d -> d % 2 == 0)\n\nsource = from(1:5) |> composition\n\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 4\n[LogActor] Data: 16\n[LogActor] Completed\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#Errors","page":"Operators","title":"Errors","text":"","category":"section"},{"location":"api/operators/","page":"Operators","title":"Operators","text":"InvalidOperatorTraitUsageError\nInconsistentSourceOperatorDataTypesError\nMissingOnCallImplementationError\nMissingOperatorRightImplementationError","category":"page"},{"location":"api/operators/#Rocket.InvalidOperatorTraitUsageError","page":"Operators","title":"Rocket.InvalidOperatorTraitUsageError","text":"This error will be thrown if |> pipe operator is called with invalid operator object\n\nSee also: on_call!\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#Rocket.InconsistentSourceOperatorDataTypesError","page":"Operators","title":"Rocket.InconsistentSourceOperatorDataTypesError","text":"This error will be thrown if |> pipe operator is called with inconsistent data type\n\nSee also: on_call!\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#Rocket.MissingOnCallImplementationError","page":"Operators","title":"Rocket.MissingOnCallImplementationError","text":"This error will be thrown if Julia cannot find specific method of on_call! function for a given operator.\n\nSee also: on_call!\n\n\n\n\n\n","category":"type"},{"location":"api/operators/#Rocket.MissingOperatorRightImplementationError","page":"Operators","title":"Rocket.MissingOperatorRightImplementationError","text":"This error will be thrown if Julia cannot find specific method of operator_right function for a given operator.\n\nSee also: operator_right\n\n\n\n\n\n","category":"type"},{"location":"observables/types/faulted/#observable_faulted","page":"Faulted","title":"Faulted Observable","text":"","category":"section"},{"location":"observables/types/faulted/","page":"Faulted","title":"Faulted","text":"faulted","category":"page"},{"location":"observables/types/faulted/#Rocket.faulted","page":"Faulted","title":"Rocket.faulted","text":"faulted(err; scheduler::H = AsapScheduler())            where { H <: AbstractScheduler }\nfaulted(::Type{T}, err; scheduler::H = AsapScheduler()) where { T, H <: AbstractScheduler }\n\nCreation operator for the FaultedObservable that emits no items to the Actor and immediately sends an error notification.\n\nArguments\n\nerr: the particular Error to pass to the error notification.\nT: type of output data source, optional, Any by default\nscheduler: optional, scheduler-like object\n\nExamples\n\nusing Rocket\n\nsource = faulted(\"Error!\")\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Error: Error!\n\n\nSee also: FaultedObservable, subscribe!\n\n\n\n\n\n","category":"function"},{"location":"observables/types/faulted/","page":"Faulted","title":"Faulted","text":"FaultedObservable","category":"page"},{"location":"observables/types/faulted/#Rocket.FaultedObservable","page":"Faulted","title":"Rocket.FaultedObservable","text":"FaultedObservable{D, H}(err, scheduler::H)\n\nObservable that emits no items to the Actor and just sends an error notification on subscription.\n\nConstructor arguments\n\nerr: error to emit on subscription\nscheduler: scheduler-like object\n\nSee also: faulted\n\n\n\n\n\n","category":"type"},{"location":"operators/multicasting/multicast/#operator_multicast","page":"multicast","title":"Multicast Operator","text":"","category":"section"},{"location":"operators/multicasting/multicast/","page":"multicast","title":"multicast","text":"multicast","category":"page"},{"location":"operators/multicasting/multicast/#Rocket.multicast","page":"multicast","title":"Rocket.multicast","text":"multicast(subject::S) where S\nmulticast(factory::F) where { F <: AbstractSubjectFactory }\n\nThe multicast()operator takes a Subject and uses it to share the source execution. It returns what’s known as aConnectableObservable`, which has a connect() method. It has one simple job - subscribes to the source with the provided subject.\n\nExample\n\nusing Rocket\n\nsubject = Subject(Int)\nsource  = from(1:5) |> multicast(subject)\n\nactor1 = logger(\"1\")\nactor2 = logger(\"2\")\n\nsubscription1 = subscribe!(source, actor1)\nsubscription2 = subscribe!(source, actor2)\n\nconnect(source)\n\nunsubscribe!(subscription1)\nunsubscribe!(subscription2)\n;\n\n# output\n\n[1] Data: 1\n[2] Data: 1\n[1] Data: 2\n[2] Data: 2\n[1] Data: 3\n[2] Data: 3\n[1] Data: 4\n[2] Data: 4\n[1] Data: 5\n[2] Data: 5\n[1] Completed\n[2] Completed\n\nSee also: ConnectableObservable, Subject, share, publish\n\n\n\n\n\n","category":"function"},{"location":"operators/multicasting/multicast/#See-also","page":"multicast","title":"See also","text":"","category":"section"},{"location":"operators/multicasting/multicast/","page":"multicast","title":"multicast","text":"Operators","category":"page"},{"location":"operators/transformation/map/#operator_map","page":"map","title":"Map Operator","text":"","category":"section"},{"location":"operators/transformation/map/","page":"map","title":"map","text":"map","category":"page"},{"location":"operators/transformation/map/#Base.map","page":"map","title":"Base.map","text":"map(::Type{R}, mappingFn::F) where { F <: Function }\n\nCreates a map operator, which applies a given mappingFn to each value emmited by the source Observable, and emits the resulting values as an Observable. You have to specify output R type after mappingFn projection.\n\nArguments\n\n::Type{R}: the type of data of transformed value, may be or may not be the same as source type\nmappingFn::Function: transformation function with (data::L) -> R signature, where L is type of data in input source\n\nProducing\n\nStream of type <: Subscribable{R}\n\nExamples\n\nusing Rocket\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> map(Int, (d) -> d ^ 2), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 4\n[LogActor] Data: 9\n[LogActor] Completed\n\nSee also: AbstractOperator, RightTypedOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/map/#Description","page":"map","title":"Description","text":"","category":"section"},{"location":"operators/transformation/map/","page":"map","title":"map","text":"Like map(f, array), the map operator applies a function to each source value.","category":"page"},{"location":"operators/transformation/map/#See-also","page":"map","title":"See also","text":"","category":"section"},{"location":"operators/transformation/map/","page":"map","title":"map","text":"Operators","category":"page"},{"location":"operators/utility/tap_on_complete/#operator_tap_on_complete","page":"tap_on_complete","title":"TapOnComplete Operator","text":"","category":"section"},{"location":"operators/utility/tap_on_complete/","page":"tap_on_complete","title":"tap_on_complete","text":"tap_on_complete","category":"page"},{"location":"operators/utility/tap_on_complete/#Rocket.tap_on_complete","page":"tap_on_complete","title":"Rocket.tap_on_complete","text":"tap_on_complete(tapFn::F) where { F <: Function }\n\nCreates a tap operator, which performs a side effect for only complete emission on the source Observable, but return an Observable that is identical to the source.\n\nArguments\n\ntapFn::Function: side-effect tap function with () -> Nothing signature\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> tap_on_complete(() -> println(\"Complete event received\")), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Completed\nComplete event received\n\n\nSee also: tap_on_subscribe, tap, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/tap_on_complete/#Description","page":"tap_on_complete","title":"Description","text":"","category":"section"},{"location":"operators/utility/tap_on_complete/","page":"tap_on_complete","title":"tap_on_complete","text":"Returns an Observable that resembles the source Observable, but modifies it so that the provided Observer is called to perform a side effect on complete event emission by the source.","category":"page"},{"location":"operators/utility/tap_on_complete/","page":"tap_on_complete","title":"tap_on_complete","text":"This operator is useful for debugging your Observables, verifying correctness, or performing other side effects.","category":"page"},{"location":"operators/utility/tap_on_complete/","page":"tap_on_complete","title":"tap_on_complete","text":"Note: this operator differs from a subscribe on the Observable. If the Observable returned by tap_on_complete is not subscribed, the side effects specified by the Observer will never happen. tap_on_complete therefore simply spies on future execution, it does not trigger an execution to happen like subscribe does.","category":"page"},{"location":"operators/utility/tap_on_complete/#See-also","page":"tap_on_complete","title":"See also","text":"","category":"section"},{"location":"operators/utility/tap_on_complete/","page":"tap_on_complete","title":"tap_on_complete","text":"Operators","category":"page"},{"location":"observables/types/combined_updates/#observable_combined_updates","page":"Combined Updates","title":"CombinedUpdates Observable","text":"","category":"section"},{"location":"observables/types/combined_updates/","page":"Combined Updates","title":"Combined Updates","text":"combineLatestUpdates","category":"page"},{"location":"observables/types/combined_updates/#Rocket.combineLatestUpdates","page":"Combined Updates","title":"Rocket.combineLatestUpdates","text":"combineLatestUpdates(sources...; strategy = PushEach())\ncombineLatestUpdates(sources::S, strategy::G = PushEach()) where { S <: Tuple, U }\n\ncombineLatestUpdates is a more effiecient version of combineLatest(sources) + map_to(sources) operators chain.\n\nArguments\n\nsources: input sources\nstrategy: optional update strategy for batching new values together\n\nNote: combineLatestUpdates() completes immediately if sources are empty.\n\nSee also: Subscribable, subscribe!, PushEach, PushEachBut, PushNew, PushNewBut, PushStrategy\n\n\n\n\n\n","category":"function"},{"location":"observables/types/combined/#observable_combined","page":"Combined","title":"Combined Observable","text":"","category":"section"},{"location":"observables/types/combined/","page":"Combined","title":"Combined","text":"combineLatest\nPushEach\nPushEachBut\nPushNew\nPushNewBut\nPushStrategy","category":"page"},{"location":"observables/types/combined/#Rocket.combineLatest","page":"Combined","title":"Rocket.combineLatest","text":"combineLatest(sources...; strategy = PushEach())\ncombineLatest(sources::S, strategy::G = PushEach()) where { S <: Tuple, U }\n\nCombines multiple Observables to create an Observable whose values are calculated from the latest values of each of its input Observables. Accept optinal update strategy object.\n\nArguments\n\nsources: input sources\nstrategy: optional update strategy for batching new values together\n\nNote: combineLatest() completes immediately if sources are empty.\n\nExamples\n\nusing Rocket\n\nlatest = combineLatest(of(1), from(2:5))\n\nsubscribe!(latest, logger())\n;\n\n# output\n\n[LogActor] Data: (1, 2)\n[LogActor] Data: (1, 3)\n[LogActor] Data: (1, 4)\n[LogActor] Data: (1, 5)\n[LogActor] Completed\n\nusing Rocket\n\nlatest = combineLatest(of(1) |> async(0), from(2:5) |> async(0), strategy = PushNew())\n\nsubscribe!(latest, logger())\n;\n\n# output\n\n[LogActor] Data: (1, 2)\n[LogActor] Completed\n\nSee also: Subscribable, subscribe!, PushEach, PushEachBut, PushNew, PushNewBut, PushStrategy\n\n\n\n\n\n","category":"function"},{"location":"observables/types/combined/#Rocket.PushEach","page":"Combined","title":"Rocket.PushEach","text":"PushEach\n\nPushEach update strategy specifies the strategy to emit new value each time an inner observable emit a new value\n\nSee also: combineLatest, PushEachBut, PushNew, PushNewBut, PushStrategy\n\n\n\n\n\n","category":"type"},{"location":"observables/types/combined/#Rocket.PushEachBut","page":"Combined","title":"Rocket.PushEachBut","text":"PushEachBut{I}\n\nPushEachBut update strategy specifies the strategy to emit new value if and only if an inner observable with index I have a new value\n\nSee also: combineLatest, PushEach, PushNew, PushNewBut, PushStrategy\n\n\n\n\n\n","category":"type"},{"location":"observables/types/combined/#Rocket.PushNew","page":"Combined","title":"Rocket.PushNew","text":"PushNew\n\nPushNew update strategy specifies the strategy to emit new value if and only if all inner observables have a new value\n\nSee also: combineLatest, PushEach, PushEachBut, PushNewBut, PushStrategy\n\n\n\n\n\n","category":"type"},{"location":"observables/types/combined/#Rocket.PushNewBut","page":"Combined","title":"Rocket.PushNewBut","text":"PushNewBut{I}\n\nPushNewBut{I} update strategy specifies the strategy to emit new value if and only if all inner observables except with index I have a new value\n\nSee also: combineLatest, PushEach, PushEachBut, PushNew, PushStrategy\n\n\n\n\n\n","category":"type"},{"location":"observables/types/combined/#Rocket.PushStrategy","page":"Combined","title":"Rocket.PushStrategy","text":"PushStrategy(strategy::BitArray{1})\n\nPushStrategy update strategy specifies the strategy to emit new value if and only if all inner observables with index such that strategy[index] = false have a new value\n\nSee also: combineLatest, PushEach, PushEachBut, PushNew, PushNewBut, collectLatest\n\n\n\n\n\n","category":"type"},{"location":"observables/types/combined/#Description","page":"Combined","title":"Description","text":"","category":"section"},{"location":"observables/types/combined/","page":"Combined","title":"Combined","text":"combineLatest combines the values from all Observables in its arguments. This is done by subscribing to each Observable in order and, whenever an Observable emits, collecting a tuple of the most recent values from each Observable (in order). If you pass n Observables to combineLatest, the returned Observable will always emit an ordered tuple of n values.","category":"page"},{"location":"observables/types/combined/","page":"Combined","title":"Combined","text":"To ensure that the output tuple has a consistent length, combineLatest waits for all input Observables to emit at least once before it starts emitting results. This means that if some Observable emits values before other Observables started emitting, all these values but the last will be lost. On the other hand, if some Observable does not emit a value but completes, the resulting Observable will complete simultaneously without emitting anything. Furthermore, if some input Observable does not emit any value and never completes, combineLatest will also never emit and never complete.","category":"page"},{"location":"observables/types/combined/","page":"Combined","title":"Combined","text":"If at least one Observable was passed to combineLatest and all passed Observables emitted, then the resulting Observable will complete when all combined streams complete. So even if some Observable completes, the result of combineLatest will still emit values when the other Observables do. In case of a completed Observable, its value will now remain to be the last emitted value. On the other hand, if any Observable errors, combineLatest will also immediately error.","category":"page"},{"location":"observables/types/combined/","page":"Combined","title":"Combined","text":"It is possible to change default update/complete strategy behaviour with an optional strategy object.","category":"page"},{"location":"operators/filtering/about/#Filtering-category","page":"About filtering operators","title":"Filtering category","text":"","category":"section"},{"location":"operators/filtering/about/","page":"About filtering operators","title":"About filtering operators","text":"There are operators for different purposes, and they may be categorized as: creation, transformation, filtering, joining, multicasting, error handling, utility, etc. In the following list you will find all the operators organized in filtering category.","category":"page"},{"location":"operators/filtering/about/","page":"About filtering operators","title":"About filtering operators","text":"filter\nfilter_type\ntake\ntake_until\nfirst\nlast\nfind\nfind_index\nignore","category":"page"},{"location":"operators/filtering/about/#See-also","page":"About filtering operators","title":"See also","text":"","category":"section"},{"location":"operators/filtering/about/","page":"About filtering operators","title":"About filtering operators","text":"Operators","category":"page"},{"location":"observables/types/connectable/#observable_connectable","page":"Connectable","title":"Connectable Observable","text":"","category":"section"},{"location":"observables/types/connectable/","page":"Connectable","title":"Connectable","text":"connectable","category":"page"},{"location":"observables/types/connectable/#Rocket.connectable","page":"Connectable","title":"Rocket.connectable","text":"connectable(subject::J, source::S) where J where S\n\nCreates a ConnectableObservable with a given subject object and a source observable.\n\nExample\n\nusing Rocket\n\nc = connectable(Subject(Int; scheduler = AsapScheduler()), from(1:3))\n\nsubscribe!(c, logger());\n\nconnect(c);\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Completed\n\n\nSee also: ConnectableObservable, connect, subscribe!\n\n\n\n\n\n","category":"function"},{"location":"observables/types/connectable/","page":"Connectable","title":"Connectable","text":"connect","category":"page"},{"location":"observables/types/connectable/#Rocket.connect","page":"Connectable","title":"Rocket.connect","text":"connect(connectable::ConnectableObservable)\n\nWhen connect is called, the subject passed to the multicast operator is subscribed to the source and the subject’s observers receive the multicast notifications, which fits our basic mental model of stream multicasting. Returns a subscription.\n\nSee also: connectable, ConnectableObservable\n\n\n\n\n\n","category":"function"},{"location":"observables/types/connectable/","page":"Connectable","title":"Connectable","text":"ConnectableObservable","category":"page"},{"location":"observables/types/connectable/#Rocket.ConnectableObservable","page":"Connectable","title":"Rocket.ConnectableObservable","text":"ConnectableObservable{D}(subject, source)\n\nA connectable observable encapsulates the multicasting infrastructure with provided subject, but does not immediately subscribe to the source. It subscribes to the source when its connect method is called.\n\nSee also: connect, Subscribable\n\n\n\n\n\n","category":"type"},{"location":"operators/utility/tap_on_unsubscribe/#operator_tap_on_unsubscribe","page":"tap_on_unsubscribe","title":"TapOnUnsubscribe Operator","text":"","category":"section"},{"location":"operators/utility/tap_on_unsubscribe/","page":"tap_on_unsubscribe","title":"tap_on_unsubscribe","text":"TapBeforeUnsubscription\nTapAfterUnsubscription\ntap_on_unsubscribe","category":"page"},{"location":"operators/utility/tap_on_unsubscribe/#Rocket.TapBeforeUnsubscription","page":"tap_on_unsubscribe","title":"Rocket.TapBeforeUnsubscription","text":"TapBeforeUnsubscription\n\nOne of the strategies for tap_on_unsubscribe operator. With TapBeforeUnubscription tap callback will be called before actual unsubscription.\n\nSee also: tap_on_unsubscribe, TapAfterUnsubscription\n\n\n\n\n\n","category":"type"},{"location":"operators/utility/tap_on_unsubscribe/#Rocket.TapAfterUnsubscription","page":"tap_on_unsubscribe","title":"Rocket.TapAfterUnsubscription","text":"TapAfterUnsubscription\n\nOne of the strategies for tap_on_unsubscribe operator. With TapBeforeUnsubscription tap callback will be called after actual unsubscription.\n\nSee also: tap_on_unsubscribe, TapBeforeUnsubscription\n\n\n\n\n\n","category":"type"},{"location":"operators/utility/tap_on_unsubscribe/#Rocket.tap_on_unsubscribe","page":"tap_on_unsubscribe","title":"Rocket.tap_on_unsubscribe","text":"tap_on_unsubscribe(tapFn::F, strategy::S = TapBeforeUnsubscription()) where { F <: Function }\n\nCreates a tap operator, which performs a side effect on the unsubscription on the source Observable, but return an Observable that is identical to the source. Tap callback triggers only once.\n\nArguments\n\ntapFn::Function: side-effect tap function with () -> Nothing signature\nstrategy: (optional), specifies the order of a side-effect and an actual unsubscription, uses TapBeforeUnsubscription by default\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource = from([ 1, 2, 3 ])\nsubscription = subscribe!(source |> tap_on_unsubscribe(() -> println(\"Someone unsubscribed\")), logger())\nunsubscribe!(subscription)\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Completed\nSomeone unsubscribed\n\nSee also: TapBeforeUnsubscription, TapAfterUnsubscription, tap, tap_on_subscribe, tap_on_complete, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/tap_on_unsubscribe/#Description","page":"tap_on_unsubscribe","title":"Description","text":"","category":"section"},{"location":"operators/utility/tap_on_unsubscribe/","page":"tap_on_unsubscribe","title":"tap_on_unsubscribe","text":"Returns an Observable that resembles the source Observable, but modifies it so that the provided Observer is called to perform a side effect on unsubscription from the source.","category":"page"},{"location":"operators/utility/tap_on_unsubscribe/","page":"tap_on_unsubscribe","title":"tap_on_unsubscribe","text":"This operator is useful for debugging your Observables, verifying correctness, or performing other side effects.","category":"page"},{"location":"operators/utility/tap_on_unsubscribe/#See-also","page":"tap_on_unsubscribe","title":"See also","text":"","category":"section"},{"location":"operators/utility/tap_on_unsubscribe/","page":"tap_on_unsubscribe","title":"tap_on_unsubscribe","text":"Operators","category":"page"},{"location":"operators/errors/about/#Error-handling-category","page":"About error handling operators","title":"Error handling category","text":"","category":"section"},{"location":"operators/errors/about/","page":"About error handling operators","title":"About error handling operators","text":"There are operators for different purposes, and they may be categorized as: creation, transformation, filtering, joining, multicasting, error handling, utility, etc. In the following list you will find all the operators organized in error handling category.","category":"page"},{"location":"operators/errors/about/","page":"About error handling operators","title":"About error handling operators","text":"catch_error\nrerun","category":"page"},{"location":"operators/errors/about/#See-also","page":"About error handling operators","title":"See also","text":"","category":"section"},{"location":"operators/errors/about/","page":"About error handling operators","title":"About error handling operators","text":"Operators","category":"page"},{"location":"operators/utility/delay/#operator_delay","page":"delay","title":"Delay Operator","text":"","category":"section"},{"location":"operators/utility/delay/","page":"delay","title":"delay","text":"delay","category":"page"},{"location":"operators/utility/delay/#Rocket.delay","page":"delay","title":"Rocket.delay","text":"delay(delay::Int)\n\nCreates a delay operator, which delays the emission of items from the source Observable by a given timeout.\n\nArguments:\n\ndelay::Int: the delay duration in milliseconds (a number) until which the emission of the source items is delayed.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/delay/#Description","page":"delay","title":"Description","text":"","category":"section"},{"location":"operators/utility/delay/","page":"delay","title":"delay","text":"Delays the emission of items from the source Observable by a given timeout","category":"page"},{"location":"operators/utility/delay/#Example","page":"delay","title":"Example","text":"","category":"section"},{"location":"operators/utility/delay/","page":"delay","title":"delay","text":"Delay every value with 1 second to the output","category":"page"},{"location":"operators/utility/delay/","page":"delay","title":"delay","text":"using Rocket\nusing Dates\n\nsource = from([ 1, 2, 3 ])\nprintln(Dates.format(now(), \"MM:SS\"))\nsubscription = subscribe!(source |> delay(2000), lambda(\n    on_next = (d) -> println(\"$(Dates.format(now(), \"MM:SS\")): $d\")\n));\n\n# output\n\n03:41\n03:43: 1\n03:43: 2\n03:43: 3\n","category":"page"},{"location":"operators/utility/delay/#See-also","page":"delay","title":"See also","text":"","category":"section"},{"location":"operators/utility/delay/","page":"delay","title":"delay","text":"Operators","category":"page"},{"location":"operators/filtering/take/#operator_take","page":"take","title":"Take Operator","text":"","category":"section"},{"location":"operators/filtering/take/","page":"take","title":"take","text":"take","category":"page"},{"location":"operators/filtering/take/#Rocket.take","page":"take","title":"Rocket.take","text":"take(maxcount::Int)\n\nCreates a take operator, which returns an Observable that emits only the first maxcount values emitted by the source Observable.\n\nArguments\n\nmaxcount::Int: the maximum number of next values to emit.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource = from([ i for i in 1:100 ])\n\nsubscribe!(source |> take(5), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Data: 4\n[LogActor] Data: 5\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/filtering/take/#Description","page":"take","title":"Description","text":"","category":"section"},{"location":"operators/filtering/take/","page":"take","title":"take","text":"take returns an Observable that emits only the first count values emitted by the source Observable. If the source emits fewer than count values, then all of its values are emitted. Afterwards, the Observable completes regardless of whether the source completed.","category":"page"},{"location":"operators/filtering/take/#See-also","page":"take","title":"See also","text":"","category":"section"},{"location":"operators/filtering/take/","page":"take","title":"take","text":"Operators","category":"page"},{"location":"operators/transformation/scan/#operator_scan","page":"scan","title":"Scan Operator","text":"","category":"section"},{"location":"operators/transformation/scan/","page":"scan","title":"scan","text":"scan","category":"page"},{"location":"operators/transformation/scan/#Rocket.scan","page":"scan","title":"Rocket.scan","text":"scan(::Type{R}, scanFn::F, seed::R) where { R, F <: Function }\nscan(scanFn::F) where { F <: Function }\n\nCreates a scan operator, which applies a given accumulator scanFn function to each value emmited by the source Observable, and returns each intermediate result with an optional seed value. If a seed value is specified, then that value will be used as the initial value for the accumulator. If no seed value is specified, the first item of the source is used as the seed.\n\nArguments\n\n::Type{R}: the type of data of transformed value, may be or may not be the same as type of input source\nscanFn::Function: accumulator function with (data::T, current::R) -> R signature\nseed::R: optional initial value for accumulator function\n\nProducing\n\nStream of type <: Subscribable{R}\n\nExamples\n\nusing Rocket\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> scan(+), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 3\n[LogActor] Data: 6\n[LogActor] Completed\n\n\nusing Rocket\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> scan(Vector{Int}, (d, c) -> [ c..., d ], Int[]), logger())\n;\n\n# output\n\n[LogActor] Data: [1]\n[LogActor] Data: [1, 2]\n[LogActor] Data: [1, 2, 3]\n[LogActor] Completed\n\n\nSee also: AbstractOperator, RightTypedOperator, ProxyObservable, reduce, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/scan/#Description","page":"scan","title":"Description","text":"","category":"section"},{"location":"operators/transformation/scan/","page":"scan","title":"scan","text":"Combines all values emitted by the source, using an accumulator function that joins a new source value with the past accumulation. This is similar to reduce, but emits the intermediate accumulations.","category":"page"},{"location":"operators/transformation/scan/","page":"scan","title":"scan","text":"Returns an Observable that applies a specified accumulator function to each item emitted by the source Observable. If a seed value is specified, then that value will be used as the initial value for the accumulator. If no seed value is specified, the first item of the source is used as the seed.","category":"page"},{"location":"operators/transformation/scan/#See-also","page":"scan","title":"See also","text":"","category":"section"},{"location":"operators/transformation/scan/","page":"scan","title":"scan","text":"Operators","category":"page"},{"location":"actors/types/buffer/#actor_buffer","page":"Buffer","title":"Buffer actor","text":"","category":"section"},{"location":"actors/types/buffer/","page":"Buffer","title":"Buffer","text":"buffer","category":"page"},{"location":"actors/types/buffer/#Rocket.buffer","page":"Buffer","title":"Rocket.buffer","text":"buffer(::Type{T}, size::Int) where T\n\nArguments\n\n::Type{T}: Type of data in buffer\nsize::Int: size of buffer\n\nCreation operator for the BufferActor actor.\n\nExamples\n\nusing Rocket\n\nactor = buffer(Int, 3)\nactor isa BufferActor{Int}\n\n# output\ntrue\n\nSee also: BufferActor, AbstractActor\n\n\n\n\n\n","category":"function"},{"location":"actors/types/buffer/","page":"Buffer","title":"Buffer","text":"BufferActor","category":"page"},{"location":"actors/types/buffer/#Rocket.BufferActor","page":"Buffer","title":"Rocket.BufferActor","text":"BufferActor{D}() where D\n\nBuffer actor provides a storage actor. It copies last incoming successful next events in a values array, throws an ErrorException on error! event and does nothing on completion event. Note: Actor does not check the size of incoming data.\n\nExamples\n\nusing Rocket\n\nsource = of([ 1, 2, 3 ])\nactor  = buffer(Int, 3)\n\nsubscribe!(source, actor)\nshow(getvalues(actor))\n\n# output\n[1, 2, 3]\n\nSee also: Actor, buffer\n\n\n\n\n\n","category":"type"},{"location":"operators/creation/about/#Creation-category","page":"Creation","title":"Creation category","text":"","category":"section"},{"location":"operators/creation/about/","page":"Creation","title":"Creation","text":"There are operators for different purposes, and they may be categorized as: creation, transformation, filtering, joining, multicasting, error handling, utility, etc. In the following list you will find all the operators organized in creation category.","category":"page"},{"location":"operators/creation/about/","page":"Creation","title":"Creation","text":"make\nof\nfrom\niterable\nfaulted\nnever\ncompleted\ntimer\ninterval\nproxy\nfile\ncombined\nrace\nconnectable\nmerged\nconcat\ngenerate\nnetwork\ndefer\nzipped","category":"page"},{"location":"operators/creation/about/#See-also","page":"Creation","title":"See also","text":"","category":"section"},{"location":"operators/creation/about/","page":"Creation","title":"Creation","text":"Operators","category":"page"},{"location":"subjects/types/recent/#subject_recent","page":"Recent","title":"RecentSubject","text":"","category":"section"},{"location":"subjects/types/recent/","page":"Recent","title":"Recent","text":"RecentSubject\nRecentSubjectFactory","category":"page"},{"location":"subjects/types/recent/#Rocket.RecentSubject","page":"Recent","title":"Rocket.RecentSubject","text":"RecentSubject(::Type{D}) where D\nRecentSubject(::Type{D}, factory::F) where { D, F <: AbstractSubjectFactory }\nRecentSubject(::Type{D}, subject::S) where { D, S }\n\nA variant of Subject that emits its recent value whenever it is subscribed to.\n\nSee also: RecentSubjectFactory, Subject, SubjectFactory\n\n\n\n\n\n","category":"function"},{"location":"subjects/types/recent/#Rocket.RecentSubjectFactory","page":"Recent","title":"Rocket.RecentSubjectFactory","text":"RecentSubjectFactory(factory::F) where { F <: AbstractSubjectFactory }\nRecentSubjectFactory(; scheduler::H = AsapScheduler()) where { H <: AbstractScheduler }\n\nA variant of SubjectFactory that creates an instance of RecentSubject.\n\nSee also: SubjectFactory, AbstractSubjectFactory, RecentSubject, Subject\n\n\n\n\n\n","category":"function"},{"location":"subjects/types/recent/#Description","page":"Recent","title":"Description","text":"","category":"section"},{"location":"subjects/types/recent/","page":"Recent","title":"Recent","text":"One of the variants of Subjects is the RecentSubject, which has a notion of \"the recent value\". It stores the latest value emitted to its consumers, and whenever a new Observer subscribes, it will immediately receive the \"recent value\" from the RecentSubject.","category":"page"},{"location":"subjects/types/recent/","page":"Recent","title":"Recent","text":"note: Note\nRecentSubjects is a more efficient version of ReplaySubjects with replay size equal to one.","category":"page"},{"location":"subjects/types/recent/#Examples","page":"Recent","title":"Examples","text":"","category":"section"},{"location":"subjects/types/recent/","page":"Recent","title":"Recent","text":"In the following example, after RecentSubject is initialized the first Observer receives nothing when it subscribes. The second Observer receives the value 2 even though it subscribed after the value 2 was sent.","category":"page"},{"location":"subjects/types/recent/","page":"Recent","title":"Recent","text":"using Rocket\n\nsubject = RecentSubject(Int)\n\nsubscription1 = subscribe!(subject, logger(\"1\"))\n\nnext!(subject, 1)\nnext!(subject, 2)\n\nsubscription2 = subscribe!(subject, logger(\"2\"))\n\nnext!(subject, 3)\n\nunsubscribe!(subscription1)\nunsubscribe!(subscription2)\n\n// Logs\n// [1] Data: 1\n// [1] Data: 2\n// [2] Data: 2\n// [1] Data: 3\n// [2] Data: 3","category":"page"},{"location":"operators/utility/noop/#operator_noop","page":"noop","title":"Noop Operator","text":"","category":"section"},{"location":"operators/utility/noop/","page":"noop","title":"noop","text":"noop","category":"page"},{"location":"operators/utility/noop/#Rocket.noop","page":"noop","title":"Rocket.noop","text":"noop()\n\nCreates a noop operator, which does nothing, but breaks operator composition type inference checking procedure for Julia's compiler. It might be useful for very long chain of operators, because Julia tries to statically infer data types at compile-time for the whole chain and can run into StackOverflow issues.\n\nusing Rocket\n\n# foo() block to enforce local scope for scope variable\nfunction foo()\n    source = from(1:5)\n\n    for i in 1:1000\n        source = source |> map(Int, d -> d + 1) |> noop()\n    end\n\n    subscribe!(source, logger())\nend\n\nfoo()\n;\n\n# output\n\n[LogActor] Data: 1001\n[LogActor] Data: 1002\n[LogActor] Data: 1003\n[LogActor] Data: 1004\n[LogActor] Data: 1005\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, logger, map\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/noop/#See-also","page":"noop","title":"See also","text":"","category":"section"},{"location":"operators/utility/noop/","page":"noop","title":"noop","text":"Operators","category":"page"},{"location":"getting-started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Rocket.jl is a Julia package for reactive programming that makes it easier to work with asynchronous data. It is inspired by the RxJS and ReactiveX communities.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In order to combine good performance with a convenient API, Rocket.jl employs Observer patterns, Actor models and Functional programming.","category":"page"},{"location":"getting-started/#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Install Rocket.jl through the Julia package manager:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"] add Rocket","category":"page"},{"location":"getting-started/#Concepts","page":"Getting started","title":"Concepts","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Rocket.jl has been designed with a focus on performance and modularity.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"The essential concepts in Rocket.jl are:","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Observable: represents a collection of future messages (data or/and events).\nActor: is an object that knows how to react on incoming messages delivered by the Observable.\nSubscription: represents a teardown logic that is useful for cancelling the execution of an Observable.\nOperator: an object that deals with collection operations, such as map, filter, reduce, etc.\nSubject: the way of multicasting a message to multiple Observers.","category":"page"},{"location":"getting-started/#First-example","page":"Getting started","title":"First example","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"Conventionally, arrays are used for processing data.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"for value in array_of_values\n    doSomethingWithMyData(value)\nend","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In contrast, Rocket.jl uses observables.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"subscription = subscribe!(source_of_values, lambda(\n    on_next     = (data)  -> doSomethingWithMyData(data),\n    on_error    = (error) -> doSomethingWithAnError(error),\n    on_complete = ()      -> println(\"Completed!\")\n))","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"At some point in time you may decide to stop listening for new messages.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"unsubscribe!(subscription)","category":"page"},{"location":"getting-started/#Actors","page":"Getting started","title":"Actors","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"In order to process messages from an observable you will need to define an Actor that knows how to react to incoming messages.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"struct MyActor <: Rocket.Actor{Int} end\n\nRocket.on_next!(actor::MyActor, data::Int) = doSomethingWithMyData(data)\nRocket.on_error!(actor::MyActor, error)    = doSomethingWithAnError(error)\nRocket.on_complete!(actor::MyActor)        = println(\"Completed!\")","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"An actor can also have its own local state.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"struct StoreActor{D} <: Rocket.Actor{D}\n    values :: Vector{D}\n\n    StoreActor{D}() where D = new(Vector{D}())\nend\n\nRocket.on_next!(actor::StoreActor{D}, data::D) where D = push!(actor.values, data)\nRocket.on_error!(actor::StoreActor, error)             = doSomethingWithAnError(error)\nRocket.on_complete!(actor::StoreActor)                 = println(\"Completed: $(actor.values)\")","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"For debugging purposes you can use a general LambdaActor actor or just pass a function object as an actor in subscribe! function..","category":"page"},{"location":"getting-started/#Operators","page":"Getting started","title":"Operators","text":"","category":"section"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"What makes Rocket.jl powerful is its ability to help you process, transform and modify the messages that flow through your observables, using Operators.","category":"page"},{"location":"getting-started/","page":"Getting started","title":"Getting started","text":"subscribe!(squared_int_values |> map(Int, (d) -> d ^ 2), lambda(\n    on_next = (data) -> println(data)\n))","category":"page"},{"location":"operators/transformation/pairwise/#operator_pairwise","page":"pairwise","title":"Pairwise Operator","text":"","category":"section"},{"location":"operators/transformation/pairwise/","page":"pairwise","title":"pairwise","text":"pairwise","category":"page"},{"location":"operators/transformation/pairwise/#Rocket.pairwise","page":"pairwise","title":"Rocket.pairwise","text":"pairwise([ initial ])\n\nCreates a pairwise operator, which groups pairs of consecutive emissions together and emits them as a tuple of two values. Accepts optional initial seed value to start pairing from.\n\nusing Rocket\n\nsource = from(1:5) |> pairwise()\n\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: (1, 2)\n[LogActor] Data: (2, 3)\n[LogActor] Data: (3, 4)\n[LogActor] Data: (4, 5)\n[LogActor] Completed\n\nusing Rocket\n\nsource = from(1:5) |> pairwise(0)\n\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: (0, 1)\n[LogActor] Data: (1, 2)\n[LogActor] Data: (2, 3)\n[LogActor] Data: (3, 4)\n[LogActor] Data: (4, 5)\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/pairwise/#See-also","page":"pairwise","title":"See also","text":"","category":"section"},{"location":"operators/transformation/pairwise/","page":"pairwise","title":"pairwise","text":"Operators","category":"page"},{"location":"operators/filtering/first/#operator_first","page":"first","title":"First operator","text":"","category":"section"},{"location":"operators/filtering/first/","page":"first","title":"first","text":"first","category":"page"},{"location":"operators/filtering/first/#Base.first","page":"first","title":"Base.first","text":"first(; default = nothing)\n\nCreates a first operator, which returns an Observable that emits only the first value emitted by the source Observable. Sends FirstNotFoundException error message if a given source completes without emitting a single value.\n\nArguments\n\ndefault: an optional default value to provide if no values were emitted\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource       = from(1:100)\nsubscription = subscribe!(source |> first(), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Completed\n\nSee also: take, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/filtering/first/#Description","page":"first","title":"Description","text":"","category":"section"},{"location":"operators/filtering/first/","page":"first","title":"first","text":"An alias for take(1) operator.","category":"page"},{"location":"operators/filtering/first/#See-also","page":"first","title":"See also","text":"","category":"section"},{"location":"operators/filtering/first/","page":"first","title":"first","text":"Operators, take","category":"page"},{"location":"actors/types/function/#actor_function","page":"Function","title":"Function actor","text":"","category":"section"},{"location":"actors/types/function/","page":"Function","title":"Function","text":"FunctionActor","category":"page"},{"location":"actors/types/function/#Rocket.FunctionActor","page":"Function","title":"Rocket.FunctionActor","text":"FunctionActor{D} <: Actor{D}\n\nFunctionActor provides a simple interface to use a single function as a next! callback, error! callback throws an ErrorException and complete! callback does nothing. Should not be used explicitly because it will be created automatically when passing a Function object as an actor in subscribe! function.\n\nExamples\n\nusing Rocket\n\nsource = from(1:5)\nsubscribe!(source, (t) -> println(t))\n;\n\n# output\n1\n2\n3\n4\n5\n\nSee also: Actor, subscribe!\n\n\n\n\n\n","category":"type"},{"location":"operators/mathematical/min/#operator_min","page":"min","title":"Min Operator","text":"","category":"section"},{"location":"operators/mathematical/min/","page":"min","title":"min","text":"min","category":"page"},{"location":"operators/mathematical/min/#Base.min","page":"min","title":"Base.min","text":"min(; from = nothing)\n\nCreates a min operator, which emits a single item: the item with the smallest value.\n\nArguments\n\nfrom: optional initial minimal value, if nothing first item from the source will be used as initial instead\n\nProducing\n\nStream of type <: Subscribable{Union{L, Nothing}} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource = from([ i for i in 1:42 ])\nsubscribe!(source |> min(), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Completed\n\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/mathematical/min/#Description","page":"min","title":"Description","text":"","category":"section"},{"location":"operators/mathematical/min/","page":"min","title":"min","text":"The min operator operates on an Observable of similar objects. When source Observable completes, it emits the item with the smallest value.","category":"page"},{"location":"operators/mathematical/min/#See-also","page":"min","title":"See also","text":"","category":"section"},{"location":"operators/mathematical/min/","page":"min","title":"min","text":"Operators","category":"page"},{"location":"subjects/about/#section_subjects","page":"Subject","title":"About subjects","text":"","category":"section"},{"location":"subjects/about/","page":"Subject","title":"Subject","text":"An Rocket.jl Subject is a special type of Observable that allows values to be multicasted to many Actors. While plain Observables are unicast (each subscribed Actor owns an independent execution of the Observable), Subjects are multicast.","category":"page"},{"location":"subjects/about/","page":"Subject","title":"Subject","text":"note: Note\nA Subject is like an Observable, but can multicast to many Actors. Subjects are like event emitters: they maintain a registry of many listeners.","category":"page"},{"location":"subjects/about/","page":"Subject","title":"Subject","text":"Every Subject is an Observable. Given a Subject, you can subscribe to it, providing an Actor, which will start receiving values normally. From the perspective of the Actor, it cannot tell whether the Observable execution is coming from a plain unicast Observable or a Subject.","category":"page"},{"location":"subjects/about/","page":"Subject","title":"Subject","text":"Internally to the Subject, subscribe does not invoke a new execution that delivers values. Instead, it simply registers the given Actor in a list of Actors.","category":"page"},{"location":"subjects/about/","page":"Subject","title":"Subject","text":"Every Subject is an Actor itself. It is an object with the methods next!, error!, and complete!. Call next!(subject, theValue) to feed a new value to the Subject, and it will be multicasted to the Actors that listen to the Subject.","category":"page"},{"location":"subjects/about/","page":"Subject","title":"Subject","text":"In the example below, we have two Observers attached to a Subject, and we feed some values to the Subject:","category":"page"},{"location":"subjects/about/","page":"Subject","title":"Subject","text":"using Rocket\n\nsource = Subject(Int)\n\nsubscription1 = subscribe!(source, lambda(\n    on_next = (d) -> println(\"Actor 1: $d\")\n))\n\nsubscription2 = subscribe!(source, lambda(\n    on_next = (d) -> println(\"Actor 2: $d\")\n))\n\nnext!(source, 0)\n\n# Logs\n# Actor 1: 0\n# Actor 2: 0\n\nunsubscribe!(subscription1)\nunsubscribe!(subscription2)\n","category":"page"},{"location":"subjects/about/","page":"Subject","title":"Subject","text":"Since a Subject is an actor, this also means you may provide a Subject as the argument to the subscribe of any Observable:","category":"page"},{"location":"subjects/about/","page":"Subject","title":"Subject","text":"using Rocket\n\nsource = Subject(Int)\n\nsubscription1 = subscribe!(source, lambda(\n    on_next = (d) -> println(\"Actor 1: $d\")\n))\n\nsubscription2 = subscribe!(source, lambda(\n    on_next = (d) -> println(\"Actor 2: $d\")\n))\n\nother_source = from([ 1, 2, 3 ])\nsubscribe!(other_source, source);\n\n# Logs\n# Actor 1: 1\n# Actor 2: 1\n# Actor 1: 2\n# Actor 2: 2\n# Actor 1: 3\n# Actor 2: 3","category":"page"},{"location":"subjects/about/","page":"Subject","title":"Subject","text":"Here, we essentially convert a unicast Observable execution to multicast, through the Subject. This demonstrates how Subjects offer a unique way to share Observable execution with multiple Observers.","category":"page"},{"location":"subjects/about/#Schedulers","page":"Subject","title":"Schedulers","text":"","category":"section"},{"location":"subjects/about/","page":"Subject","title":"Subject","text":"Subject (and some other observables) uses scheduler objects to schedule message delivery to their listeners.","category":"page"},{"location":"subjects/about/#Synchronous-scheduler","page":"Subject","title":"Synchronous scheduler","text":"","category":"section"},{"location":"subjects/about/","page":"Subject","title":"Subject","text":"One of the variants of schedulers is the AsapScheduler, which delivers every message synchronously. AsapScheduler is a default scheduler for all Subject objects.","category":"page"},{"location":"subjects/about/","page":"Subject","title":"Subject","text":"AsapScheduler","category":"page"},{"location":"subjects/about/#Rocket.AsapScheduler","page":"Subject","title":"Rocket.AsapScheduler","text":"AsapScheduler\n\nAsapScheduler executes scheduled actions as soon as possible and does not introduce any additional logic. AsapScheduler is a default scheduler for almost all observables.\n\n\n\n\n\n","category":"type"},{"location":"subjects/about/","page":"Subject","title":"Subject","text":"using Rocket\n\nsubject = Subject(Int, scheduler = AsapScheduler())\n\nsubscription1 = subscribe!(subject, logger(\"Actor 1\"))\n\nprintln(\"Before next\")\nnext!(subject, 1)\nnext!(subject, 2)\nprintln(\"After next\")\n\nsubscription2 = subscribe!(subject, logger(\"Actor 2\"))\n\nnext!(subject, 3)\n\n# Logs\n# Before next\n# [Actor 1] Data: 1\n# [Actor 1] Data: 2\n# After next\n# [Actor 1] Data: 3\n# [Actor 2] Data: 3","category":"page"},{"location":"subjects/about/#Asynchronous-Scheduler","page":"Subject","title":"Asynchronous Scheduler","text":"","category":"section"},{"location":"subjects/about/","page":"Subject","title":"Subject","text":"An AsyncScheduler is similar to a AsapScheduler. Both allows for Subject to scheduler their messages for multiple listeners, but a AsyncScheduler delivers all messages asynchronously (but still ordered) using a Julia's built-in Task object.","category":"page"},{"location":"subjects/about/","page":"Subject","title":"Subject","text":"AsyncScheduler","category":"page"},{"location":"subjects/about/#Rocket.AsyncScheduler","page":"Subject","title":"Rocket.AsyncScheduler","text":"AsyncScheduler\n\nAsyncScheduler executes scheduled actions asynchronously and uses Channel object to order different actions on a single asynchronous task\n\n\n\n\n\n","category":"type"},{"location":"subjects/about/","page":"Subject","title":"Subject","text":"using Rocket\n\nsubject = Subject(Int, scheduler = AsyncScheduler())\n\nsubscription1 = subscribe!(subject, logger(\"Actor 1\"))\n\nprintln(\"Before next\")\nnext!(subject, 1)\nnext!(subject, 2)\nprintln(\"After next\")\n\nsubscription2 = subscribe!(subject, logger(\"Actor 2\"))\n\nnext!(subject, 3)\n\n# Logs\n# Before next\n# After next\n# [Actor 1] Data: 1\n# [Actor 1] Data: 2\n# [Actor 1] Data: 3\n# [Actor 2] Data: 3\n","category":"page"},{"location":"operators/filtering/find_index/#operator_find_index","page":"find_index","title":"Find Index operator","text":"","category":"section"},{"location":"operators/filtering/find_index/","page":"find_index","title":"find_index","text":"find_index","category":"page"},{"location":"operators/filtering/find_index/#Rocket.find_index","page":"find_index","title":"Rocket.find_index","text":"find_index(conditionFn::F) where { F <: Function }\n\nCreates a find operator, which emits only the index of the first value emitted by the source Observable that meets some condition. Indices are 1-based.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nArguments\n\nconditionFn::F: condition function with (data::T) -> Bool signature\n\nExamples\n\nusing Rocket\n\nsource = from([ 0, 1, 2, 3, 4, 5, 6, 7, 8 ])\nsubscribe!(source |> find_index((d) -> d !== 0 && d % 2 == 0), logger())\n;\n\n# output\n\n[LogActor] Data: 3\n[LogActor] Completed\n\nSee also: find, AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/filtering/find_index/#Description","page":"find_index","title":"Description","text":"","category":"section"},{"location":"operators/filtering/find_index/","page":"find_index","title":"find_index","text":"It's like find, but emits the index of the found value, not the value itself.","category":"page"},{"location":"operators/filtering/find_index/#See-also","page":"find_index","title":"See also","text":"","category":"section"},{"location":"operators/filtering/find_index/","page":"find_index","title":"find_index","text":"Operators, take","category":"page"},{"location":"api/subjects/#subjects_api","page":"Subjects","title":"Subjects API","text":"","category":"section"},{"location":"api/subjects/#Traits","page":"Subjects","title":"Traits","text":"","category":"section"},{"location":"api/subjects/","page":"Subjects","title":"Subjects","text":"SubjectTrait\nas_subject  \nValidSubjectTrait\nInvalidSubjectTrait\nAbstractSubject","category":"page"},{"location":"api/subjects/#Rocket.SubjectTrait","page":"Subjects","title":"Rocket.SubjectTrait","text":"Abstract type for all possible subject traits\n\nSee also: ValidSubjectTrait, InvalidSubjectTrait, as_subject\n\n\n\n\n\n","category":"type"},{"location":"api/subjects/#Rocket.as_subject","page":"Subjects","title":"Rocket.as_subject","text":"as_subject(::Type)\n\nThis function checks subject trait behavior specification. Should be used explicitly to specify subject trait behavior for any object type.\n\nSee also: SubjectTrait\n\n\n\n\n\n","category":"function"},{"location":"api/subjects/#Rocket.ValidSubjectTrait","page":"Subjects","title":"Rocket.ValidSubjectTrait","text":"Valid subject trait behavior\n\nSee also: SubjectTrait\n\n\n\n\n\n","category":"type"},{"location":"api/subjects/#Rocket.InvalidSubjectTrait","page":"Subjects","title":"Rocket.InvalidSubjectTrait","text":"Default subject trait behavior for all types.\n\nSee also: SubjectTrait\n\n\n\n\n\n","category":"type"},{"location":"api/subjects/#Rocket.AbstractSubject","page":"Subjects","title":"Rocket.AbstractSubject","text":"Supertype for Subject types. Automatically specifies ValidSubject, SimpleSubscribableTrait and BaseActorTrait traits.\n\nSee also: Subject, ValidSubjectTrait, SimpleSubscribableTrait, BaseActorTrait\n\n\n\n\n\n","category":"type"},{"location":"api/subjects/#Factory","page":"Subjects","title":"Factory","text":"","category":"section"},{"location":"api/subjects/","page":"Subjects","title":"Subjects","text":"AbstractSubjectFactory\ncreate_subject","category":"page"},{"location":"api/subjects/#Rocket.AbstractSubjectFactory","page":"Subjects","title":"Rocket.AbstractSubjectFactory","text":"Abstract type for all possible subject factories\n\nSee also: SubjectTrait, ValidSubjectTrait, InvalidSubjectTrait\n\n\n\n\n\n","category":"type"},{"location":"api/subjects/#Rocket.create_subject","page":"Subjects","title":"Rocket.create_subject","text":"create_subject(::Type{L}, factory::F) where L where { F <: AbstractSubjectFactory }\n\nActor creator function for a given factory F. Should be implemented explicitly for any AbstractActorFactory object\n\nSee also: AbstractSubjectFactory, MissingCreateActorFactoryImplementationError\n\n\n\n\n\n","category":"function"},{"location":"api/subjects/#Errors","page":"Subjects","title":"Errors","text":"","category":"section"},{"location":"api/subjects/","page":"Subjects","title":"Subjects","text":"InvalidSubjectTraitUsageError\nInconsistentSubjectDataTypesError","category":"page"},{"location":"api/subjects/#Rocket.InvalidSubjectTraitUsageError","page":"Subjects","title":"Rocket.InvalidSubjectTraitUsageError","text":"InvalidSubject usage error\n\nSee also: as_subject\n\n\n\n\n\n","category":"type"},{"location":"api/subjects/#Rocket.InconsistentSubjectDataTypesError","page":"Subjects","title":"Rocket.InconsistentSubjectDataTypesError","text":"InconsistentSubjectDataTypesError\n\nSee also: as_subject\n\n\n\n\n\n","category":"type"},{"location":"operators/transformation/lowercase/#operator_lowercase","page":"lowercase","title":"Lowercase Operator","text":"","category":"section"},{"location":"operators/transformation/lowercase/","page":"lowercase","title":"lowercase","text":"lowercase","category":"page"},{"location":"operators/transformation/lowercase/#Base.Unicode.lowercase","page":"lowercase","title":"Base.Unicode.lowercase","text":"lowercase()\n\nCreates an lowercase operator, which forces each value to be in lower case\n\nProducing\n\nStream of type <: Subscribable{L} where L referes to type of data of input Observable\n\nExamples\n\nusing Rocket\n\nsource = of(\"Hello, world!\")\nsubscribe!(source |> lowercase(), logger())\n;\n\n# output\n\n[LogActor] Data: hello, world!\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/lowercase/#See-also","page":"lowercase","title":"See also","text":"","category":"section"},{"location":"operators/transformation/lowercase/","page":"lowercase","title":"lowercase","text":"Operators, map, uppercase","category":"page"},{"location":"operators/transformation/merge_map/#operator_merge_map","page":"merge_map","title":"MergeMap Operator","text":"","category":"section"},{"location":"operators/transformation/merge_map/","page":"merge_map","title":"merge_map","text":"merge_map","category":"page"},{"location":"operators/transformation/merge_map/#Rocket.merge_map","page":"merge_map","title":"Rocket.merge_map","text":"merge_map(::Type{R}, mappingFn::F = identity; concurrent::Int = typemax(Int)) where { R, F <: Function }\n\nCreates a merge_map operator, which returns an Observable that emits the result of applying the projection function mappingFn to each item emitted by the source Observable and merging the results of the Observables obtained from this transformation.\n\nArguments\n\n::Type{R}: the type of data of output Observables after projection with mappingFn\nmappingFn::F: projection function with (data) -> Observable{R} signature\nconcurrent::Int: optional, default is typemax(Int), maximum number of input Observables being subscribed to concurrently\n\nProducing\n\nStream of type <: Subscribable{R}\n\nExamples\n\nusing Rocket\n\nsource = from([ 0, 0 ]) |> merge_map(Int, d -> from([ 1, 2, 3 ], scheduler = AsyncScheduler(0)))\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Data: 3\n[LogActor] Completed\n\nSee also: AbstractOperator, RightTypedOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/merge_map/#See-also","page":"merge_map","title":"See also","text":"","category":"section"},{"location":"operators/transformation/merge_map/","page":"merge_map","title":"merge_map","text":"Operators","category":"page"},{"location":"teardown/types/void/#teardown_void","page":"Void","title":"Void Teardown","text":"","category":"section"},{"location":"teardown/types/void/","page":"Void","title":"Void","text":"VoidTeardown\nvoidTeardown","category":"page"},{"location":"teardown/types/void/#Rocket.VoidTeardown","page":"Void","title":"Rocket.VoidTeardown","text":"VoidTeardown()\n\nVoidTeardown object does nothing on unsubscription. It is usefull for synchronous observables and observables which cannot be cancelled after execution.\n\nSee also: Teardown, VoidTeardownLogic\n\n\n\n\n\n","category":"type"},{"location":"teardown/types/void/#Rocket.voidTeardown","page":"Void","title":"Rocket.voidTeardown","text":"voidTeardown\n\nAn instance of VoidTeardown singleton object.\n\nSee also: VoidTeardown\n\n\n\n\n\n","category":"constant"},{"location":"operators/transformation/substitute/#operator_substitute","page":"substitute","title":"Substitute Operator","text":"","category":"section"},{"location":"operators/transformation/substitute/","page":"substitute","title":"substitute","text":"substitute\nSubstituteHandler","category":"page"},{"location":"operators/transformation/substitute/#Rocket.substitute","page":"substitute","title":"Rocket.substitute","text":"substitute(::Type{T}, mapFn::F, handler::SubstituteHandler) where { T, F <: Function }\n\nThis operator forces observable to substitute each emmited value with the latest computed value with the corresponding handler and release! function. After release! on handler substitute operator computes new value with mapFn but does not emit it until next emission from source observable.  Always calls mapFn on first value from source observable.\n\nProducing\n\nStream of type <: Subscribable{T} \n\nExamples\n\nusing Rocket\n\nsubject = Subject(Int)\n\nhandler = SubstituteHandler()\nsource  = subject |> substitute(String, i -> string(\"i = \", i), handler)\n\nsubscription = subscribe!(source, logger())\n\nnext!(subject, 1)\nnext!(subject, 2)\nnext!(subject, 3)\n\nrelease!(handler)\n\nnext!(subject, 4)\nnext!(subject, 5)\nnext!(subject, 6)\n\nunsubscribe!(subscription)\n;\n\n# output\n\n[LogActor] Data: i = 1\n[LogActor] Data: i = 1\n[LogActor] Data: i = 1\n[LogActor] Data: i = 3\n[LogActor] Data: i = 3\n[LogActor] Data: i = 3\n\nSee also: SubstituteHandler\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/substitute/#Rocket.SubstituteHandler","page":"substitute","title":"Rocket.SubstituteHandler","text":"SubstituteHandler()\n\nhandler used to release! new values in substitute operator.\n\nSee also: substitute\n\n\n\n\n\n","category":"type"},{"location":"operators/transformation/substitute/#See-also","page":"substitute","title":"See also","text":"","category":"section"},{"location":"operators/transformation/substitute/","page":"substitute","title":"substitute","text":"Operators","category":"page"},{"location":"operators/mathematical/about/#Mathematical-and-Aggregate-category","page":"About mathematical operators","title":"Mathematical and Aggregate category","text":"","category":"section"},{"location":"operators/mathematical/about/","page":"About mathematical operators","title":"About mathematical operators","text":"There are operators for different purposes, and they may be categorized as: creation, transformation, filtering, joining, multicasting, error handling, utility, etc. In the following list you will find all the operators organized in mathematical and aggregate category.","category":"page"},{"location":"operators/mathematical/about/","page":"About mathematical operators","title":"About mathematical operators","text":"count\nmax\nmin\nreduce\nsum","category":"page"},{"location":"operators/mathematical/about/#See-also","page":"About mathematical operators","title":"See also","text":"","category":"section"},{"location":"operators/mathematical/about/","page":"About mathematical operators","title":"About mathematical operators","text":"Operators","category":"page"},{"location":"operators/utility/async/#operator_ref_async","page":"async","title":"Async Operator","text":"","category":"section"},{"location":"operators/utility/async/","page":"async","title":"async","text":"async","category":"page"},{"location":"operators/utility/async/#Rocket.async","page":"async","title":"Rocket.async","text":"async(size::Int = typemax(Int))\n\nCreates an async operator, which sends items from the source Observable asynchronously.\n\nArguments\n\nsize: Asynchronous messages buffer size, default is a typemax(Int)\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/async/#See-also","page":"async","title":"See also","text":"","category":"section"},{"location":"operators/utility/async/","page":"async","title":"async","text":"Operators","category":"page"},{"location":"operators/transformation/enumerate/#operator_enumerate","page":"enumerate","title":"Enumerate Operator","text":"","category":"section"},{"location":"operators/transformation/enumerate/","page":"enumerate","title":"enumerate","text":"enumerate","category":"page"},{"location":"operators/transformation/enumerate/#Base.Iterators.enumerate","page":"enumerate","title":"Base.Iterators.enumerate","text":"enumerate()\n\nCreates an enumerate operator, which converts each value emitted by the source Observable into a tuple of its order number and the value itself.\n\nThe enumerate operator is similar to scan(Tuple{Int, Int}, (d, c) -> (d, c[2] + 1), (0, 0)) (see scan).\n\nProducing\n\nStream of type <: Subscribable{Tuple{Int, L}} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource = from([ 0 for _ in 1:3 ])\nsubscribe!(source |> enumerate(), logger())\n;\n\n# output\n\n[LogActor] Data: (1, 0)\n[LogActor] Data: (2, 0)\n[LogActor] Data: (3, 0)\n[LogActor] Completed\n\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, scan, map, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/enumerate/#Description","page":"enumerate","title":"Description","text":"","category":"section"},{"location":"operators/transformation/enumerate/","page":"enumerate","title":"enumerate","text":"enumerate returns an Observable that converts each value emitted by the source Observable into a tuple of its order number and the value itself.","category":"page"},{"location":"operators/transformation/enumerate/#Example","page":"enumerate","title":"Example","text":"","category":"section"},{"location":"operators/transformation/enumerate/","page":"enumerate","title":"enumerate","text":"Get a value from the source with its order number","category":"page"},{"location":"operators/transformation/enumerate/","page":"enumerate","title":"enumerate","text":"using Rocket\n\nsource = from([ 0.0, 0.2, 0.4, 0.6, 0.8, 1.0 ])\nsubscribe!(source |> enumerate(), logger())\n\n# output\n\n[LogActor] Data: (0.0, 1)\n[LogActor] Data: (0.2, 2)\n[LogActor] Data: (0.4, 3)\n[LogActor] Data: (0.6, 4)\n[LogActor] Data: (0.8, 5)\n[LogActor] Data: (1.0, 6)\n[LogActor] Completed","category":"page"},{"location":"operators/transformation/enumerate/#See-also","page":"enumerate","title":"See also","text":"","category":"section"},{"location":"operators/transformation/enumerate/","page":"enumerate","title":"enumerate","text":"Operators, scan","category":"page"},{"location":"actors/types/sync/#actor_sync","page":"Sync","title":"Sync actor","text":"","category":"section"},{"location":"actors/types/sync/","page":"Sync","title":"Sync","text":"sync","category":"page"},{"location":"actors/types/sync/#Rocket.sync","page":"Sync","title":"Rocket.sync","text":"sync(actor::A; withlock::Bool = true, timeout::Int = -1) where A\nsync(factory::F; withlock::Bool = true, timeout::Int = -1) where { F <: AbstractActorFactory }\n\nCreation operator for the SyncActor actor. Accepts optional named timeout argument which specifies maximum number of milliseconds to wait (throws SyncActorTimedOutException() on timeout). Also accepts optional withlock boolean flag indicating that every next!, error! and complete! event should be guarded with ReentrantLock.\n\nExamples\n\nusing Rocket\n\nactor  = keep(Int)\nsynced = sync(actor)\n\nsubscribe!(from(0:5, scheduler = AsyncScheduler()), synced)\n\nyield()\n\nwait(synced)\nshow(synced.actor.values)\n\n# output\n[0, 1, 2, 3, 4, 5]\n\nCan also be used with an <: AbstractActorFactory as an argument. In this case sync function will return a special actor factory object, which will store all created actors in array and wrap them with a sync function. wait(sync_factory) method will wait for all of the created actors to be completed in the order of creation (but only once for each of them).\n\nusing Rocket\n\nvalues = Int[]\n\nfactory  = lambda(on_next = (d) -> push!(values, d))\nsynced   = sync(factory)\n\nsubscribe!(from(0:5, scheduler = AsyncScheduler()), synced)\n\nyield()\n\nwait(synced)\nshow(values)\n\n# output\n[0, 1, 2, 3, 4, 5]\n\nSee also: SyncActor, AbstractActor\n\n\n\n\n\n","category":"function"},{"location":"actors/types/sync/","page":"Sync","title":"Sync","text":"SyncActor","category":"page"},{"location":"actors/types/sync/#Rocket.SyncActor","page":"Sync","title":"Rocket.SyncActor","text":"SyncActor{T, A}(actor::A; withlock::Bool = true, timeout::Int = -1) where { T, A }\n\nSync actor provides a synchronized interface to wait for an actor to be notified with a complete event. By default creates a re-entrant lock for synchronizing next!, error! and complete! events.\n\nSee also: Actor, sync\n\n\n\n\n\n","category":"type"},{"location":"operators/utility/limit_subscribers/#operator_limit_subscribers","page":"limit_subscribers","title":"LimitSubscribers Operator","text":"","category":"section"},{"location":"operators/utility/limit_subscribers/","page":"limit_subscribers","title":"limit_subscribers","text":"LimitSubscribersGuard\nlimit_subscribers","category":"page"},{"location":"operators/utility/limit_subscribers/#Rocket.LimitSubscribersGuard","page":"limit_subscribers","title":"Rocket.LimitSubscribersGuard","text":"LimitSubscribersGuard(limit::Int = 1, exclusive = true)\n\nGuard structure used in limit_subscribers operator.\n\nArguments\n\nlimit: number of concurrent subscribers\nexclusive: boolean flag, which indicates whenever this guard can be shared with other observables in other limit_subscribers operator. If set to true, reusing this guard in a different limit_subscribers operator for other observable will result in automatic unsubscription of all present actors.\n\nNote\n\nThis structure is useful in Pluto.jl notebooks in particular, allowing for automatic subscription/unsubscription of observables.\n\nExample\n\n\n# Cell 1\nguard = LimitSubscribersGuard()\n\n# Cell 2\nsubscription = subscribe!(some_stream |> limit_subscribers(guard), logger())\n\nSee also: limit_subscribers, subscribe!\n\n\n\n\n\n","category":"type"},{"location":"operators/utility/limit_subscribers/#Rocket.limit_subscribers","page":"limit_subscribers","title":"Rocket.limit_subscribers","text":"limit_subscribers(limit::Int = 1, exclusive::Bool = true)\nlimit_subscribers(guard::LimitSubscribersGuard)\n\nCreates an operator that limits number of concurrent actors to the given observable. On new subscription, if limit is exceeded, oldest actor is automatically unsubscribed and receives a completion event.\n\nArguments\n\nlimit: number of concurrent subscribers\nexclusive: boolean flag, which indicates whenever this guard can be shared with other observables in other limit_subscribers operator. If set to true, reusing this guard in a different limit_subscribers operator for other observable will result in automatic unsubscription of all present actors.\n\nNote\n\nThis structure is useful in Pluto.jl notebooks in particular, allowing for automatic subscription/unsubscription of observables.\n\nExample\n\n\n# Cell 1\nguard = LimitSubscribersGuard()\n\n# Cell 2\nsubscription = subscribe!(some_stream |> limit_subscribers(guard), logger())\n\nSee also: LimitSubscribersGuard\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/limit_subscribers/#See-also","page":"limit_subscribers","title":"See also","text":"","category":"section"},{"location":"operators/utility/limit_subscribers/","page":"limit_subscribers","title":"limit_subscribers","text":"Operators","category":"page"},{"location":"operators/utility/skip_error/#operator_skip_error","page":"skip_error","title":"SkipError Operator","text":"","category":"section"},{"location":"operators/utility/skip_error/","page":"skip_error","title":"skip_error","text":"skip_error","category":"page"},{"location":"operators/utility/skip_error/#Rocket.skip_error","page":"skip_error","title":"Rocket.skip_error","text":"skip_error()\n\nCreates a skip_error operator, which filters out error event by the source Observable by emitting only next and complete messages.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource = faulted(\"error\")\nsubscribe!(source |> skip_error(), logger())\n;\n\n# output\n\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, skip_error, skip_complete, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/skip_error/#See-also","page":"skip_error","title":"See also","text":"","category":"section"},{"location":"operators/utility/skip_error/","page":"skip_error","title":"skip_error","text":"Operators","category":"page"},{"location":"api/observables/#observables_api","page":"Observables","title":"Observables API","text":"","category":"section"},{"location":"api/observables/","page":"Observables","title":"Observables","text":"Any observable-like should implement a valid subscribable logic.","category":"page"},{"location":"api/observables/#Traits","page":"Observables","title":"Traits","text":"","category":"section"},{"location":"api/observables/","page":"Observables","title":"Observables","text":"as_subscribable\nSubscribableTrait\nSimpleSubscribableTrait\nScheduledSubscribableTrait\nInvalidSubscribableTrait","category":"page"},{"location":"api/observables/#Rocket.as_subscribable","page":"Observables","title":"Rocket.as_subscribable","text":"as_subscribable(any)\n\nThis function checks subscribable trait behavior specification. Can be used explicitly to specify subscribable trait behavior for any object.\n\nSee also: SubscribableTrait\n\n\n\n\n\n","category":"function"},{"location":"api/observables/#Rocket.SubscribableTrait","page":"Observables","title":"Rocket.SubscribableTrait","text":"Abstract type for all possible subscribable traits\n\nSee also: SimpleSubscribableTrait, ScheduledSubscribableTrait, InvalidSubscribableTrait\n\n\n\n\n\n","category":"type"},{"location":"api/observables/#Rocket.SimpleSubscribableTrait","page":"Observables","title":"Rocket.SimpleSubscribableTrait","text":"Simple subscribable trait behavior. Simple subscribable can be used in subscribe! function and just executes on_subscribe! method for provided subscribable. SimpleSubscribableTrait is a subtype of SubscribableTrait.\n\nSee also: SubscribableTrait, Subscribable, subscribe!, on_subscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/observables/#Rocket.ScheduledSubscribableTrait","page":"Observables","title":"Rocket.ScheduledSubscribableTrait","text":"Scheduled subscribable trait behavior. Scheduled subscribable can be used in subscribe! function and executes on_subscribe! method for provided subscribable with custom scheduling. ScheduledSubscribableTrait is a subtype of SubscribableTrait.\n\nSee also: SubscribableTrait, ScheduledSubscribable, subscribe!, on_subscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/observables/#Rocket.InvalidSubscribableTrait","page":"Observables","title":"Rocket.InvalidSubscribableTrait","text":"Default subscribable trait behavior for all types. Invalid subscribable cannot be used in subscribe! function, doing so will throw an error. InvalidSubscribableTrait is a subtype of SubscribableTrait.\n\nSee also: SubscribableTrait, subscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/observables/#Types","page":"Observables","title":"Types","text":"","category":"section"},{"location":"api/observables/","page":"Observables","title":"Observables","text":"AbstractSubscribable\nSubscribable\nScheduledSubscribable\nsubscribe!\non_subscribe!","category":"page"},{"location":"api/observables/#Rocket.AbstractSubscribable","page":"Observables","title":"Rocket.AbstractSubscribable","text":"Supertype type for Subscribable and ScheduledSubscribable types.\n\nSee also: Subscribable, ScheduledSubscribable\n\n\n\n\n\n","category":"type"},{"location":"api/observables/#Rocket.Subscribable","page":"Observables","title":"Rocket.Subscribable","text":"Super type for any simple subscribable object. Automatically specifies a SimpleSubscribableTrait trait behavior. Objects with specified SimpleSubscribableTrait subscribable trait must implement: on_subscribe!(subscribable, actor) method. Subscribable is a subtype of AbstractSubscribable type.\n\nExamples\n\nusing Rocket\n\nstruct MySubscribable <: Subscribable{String} end\n\nRocket.as_subscribable(MySubscribable)\n\n# output\n\nSimpleSubscribableTrait{String}()\n\nSee also: SubscribableTrait, SimpleSubscribableTrait\n\n\n\n\n\n","category":"type"},{"location":"api/observables/#Rocket.ScheduledSubscribable","page":"Observables","title":"Rocket.ScheduledSubscribable","text":"Super type for any scheduled subscribable object. Automatically specifies a ScheduledSubscribableTrait trait behavior. Objects with specified ScheduledSubscribableTrait subscribable trait must implement: on_subscribe!(subscribable, actor, scheduler) method. ScheduledSubscribable is a subtype of AbstractSubscribable type.\n\nExamples\n\nusing Rocket\n\nstruct MyScheduledSubscribable <: ScheduledSubscribable{String} end\n\nRocket.as_subscribable(MyScheduledSubscribable)\n\n# output\n\nScheduledSubscribableTrait{String}()\n\nSee also: SubscribableTrait, ScheduledSubscribableTrait\n\n\n\n\n\n","category":"type"},{"location":"api/observables/#Rocket.subscribe!","page":"Observables","title":"Rocket.subscribe!","text":"subscribe!(subscribable::T, actor::S)   where { T, S }\nsubscribe!(subscribable::T, factory::F) where { T, F <: AbstractActorFactory }\nsubscribe!(subscriptions::Tuple)\nsubscribe!(subscriptions::AbstractVector)\n\nsubscribe! function is used to attach an actor to subscribable. It also checks types of subscribable and actors to be a valid Subscribable and Actor objects respectively. Passing not valid subscribable or/and actor object will throw an error. If the input argument to the subscribe! function is either a tuple or a vector,  it will first check that all of the arguments are valid source and actor objects  and if its true will subscribe for each of them individually. \n\nArguments\n\nsubscribable: valid subscribable object\nactor: valid actor object\n\nExamples\n\nusing Rocket\n\nsource = from((1, 2, 3))\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Completed\n\nusing Rocket\n\nsource = from((1, 2, 3))\nsubscribe!(source, 1)\n;\n\n# output\n\nERROR: Type Int64 is not a valid actor type.\n[...]\n\nusing Rocket\n\nsource = from((1, 2, 3))\nsubscribe!(1, logger())\n;\n\n# output\n\nERROR: Type Int64 is not a valid subscribable type.\n[...]\n\nSee also: on_subscribe!, as_subscribable\n\n\n\n\n\n","category":"function"},{"location":"api/observables/#Rocket.on_subscribe!","page":"Observables","title":"Rocket.on_subscribe!","text":"on_subscribe!(subscribable, actor)\non_subscribe!(subscribable, actor, scheduler)\n\nEvery valid subscribable object have to define its own method for on_subscribe! function which specifies subscription logic and has return a valid Teardown object.\n\nObjects with specified SimpleSubscribableTrait subscribable trait must implement: on_subscribe!(subscribable, actor) method. Objects with specified ScheduledSubscribableTrait subscribable trait must implement: on_subscribe!(subscribable, actor, scheduler) method.\n\nArguments\n\nsubscribable: Subscribable object\nactor: Actor object\nscheduler: Scheduler object (only for scheduled subscribables)\n\nExamples\n\nusing Rocket\n\nstruct MySubscribable <: Subscribable{Int} end\n\nfunction Rocket.on_subscribe!(subscribable::MySubscribable, actor)\n    next!(actor, 0)\n    complete!(actor)\n    return voidTeardown\nend\n\nsubscribe!(MySubscribable(), logger())\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Completed\n\nusing Rocket\n\nstruct MyScheduledSubscribable <: ScheduledSubscribable{Int} end\n\nRocket.getscheduler(::MyScheduledSubscribable) = AsapScheduler()\n\nfunction Rocket.on_subscribe!(subscribable::MyScheduledSubscribable, actor, scheduler)\n    next!(actor, 0, scheduler)\n    complete!(actor, scheduler)\n    return voidTeardown\nend\n\nsubscribe!(MyScheduledSubscribable(), logger())\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Completed\n\nSee also: Subscribable, ScheduledSubscribable, SimpleSubscribableTrait, ScheduledSubscribableTrait, Teardown, logger\n\n\n\n\n\n","category":"function"},{"location":"api/observables/#Errors","page":"Observables","title":"Errors","text":"","category":"section"},{"location":"api/observables/","page":"Observables","title":"Observables","text":"InvalidSubscribableTraitUsageError\nInconsistentActorWithSubscribableDataTypesError\nMissingOnSubscribeImplementationError\nMissingOnScheduledSubscribeImplementationError","category":"page"},{"location":"api/observables/#Rocket.InvalidSubscribableTraitUsageError","page":"Observables","title":"Rocket.InvalidSubscribableTraitUsageError","text":"This error will be thrown if subscribe! function is called with invalid subscribable object\n\nSee also: subscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/observables/#Rocket.InconsistentActorWithSubscribableDataTypesError","page":"Observables","title":"Rocket.InconsistentActorWithSubscribableDataTypesError","text":"This error will be thrown if subscribe! function is called with inconsistent subscribable and actor objects\n\nSee also: subscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/observables/#Rocket.MissingOnSubscribeImplementationError","page":"Observables","title":"Rocket.MissingOnSubscribeImplementationError","text":"This error will be thrown if Julia cannot find specific method of 'on_subscribe!()' function for given subscribable and actor\n\nSee also: on_subscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/observables/#Rocket.MissingOnScheduledSubscribeImplementationError","page":"Observables","title":"Rocket.MissingOnScheduledSubscribeImplementationError","text":"This error will be thrown if Julia cannot find specific method of 'on_subscribe!()' function for given subscribable, actor and scheduler\n\nSee also: on_subscribe!\n\n\n\n\n\n","category":"type"},{"location":"operators/mathematical/sum/#operator_sum","page":"sum","title":"Sum Operator","text":"","category":"section"},{"location":"operators/mathematical/sum/","page":"sum","title":"sum","text":"sum","category":"page"},{"location":"operators/mathematical/sum/#Base.sum","page":"sum","title":"Base.sum","text":"sum(; from = nothing)\n\nCreates a sum operator, which applies a sum accumulator function over the source Observable, and returns the accumulated result when the source completes, given an optional initial value.\n\nThe sum operator is similar to reduce(T, T, +) (see reduce).\n\nArguments\n\nfrom: optional initial accumulation value, if nothing first value will be used instead\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource = from([ i for i in 1:42 ])\nsubscribe!(source |> sum(), logger())\n;\n\n# output\n\n[LogActor] Data: 903\n[LogActor] Completed\n\n\nusing Rocket\n\nsource = from([ i for i in 1:42 ])\nsubscribe!(source |> sum(from = 97), logger())\n;\n\n# output\n\n[LogActor] Data: 1000\n[LogActor] Completed\n\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, reduce, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/mathematical/sum/#Description","page":"sum","title":"Description","text":"","category":"section"},{"location":"operators/mathematical/sum/","page":"sum","title":"sum","text":"sum operates on an Observable of objects on which + is defined. When the source Observable completes, it emits the sum of all previous items. The sum operator is similar to reduce(T, T, +) (see reduce).","category":"page"},{"location":"operators/mathematical/sum/#See-also","page":"sum","title":"See also","text":"","category":"section"},{"location":"operators/mathematical/sum/","page":"sum","title":"sum","text":"Operators, reduce","category":"page"},{"location":"actors/types/void/#actor_void","page":"Void","title":"Void actor","text":"","category":"section"},{"location":"actors/types/void/","page":"Void","title":"Void","text":"void","category":"page"},{"location":"actors/types/void/#Rocket.void","page":"Void","title":"Rocket.void","text":"void()\nvoid(::Type{T}) where T\n\nCreation operator for the VoidActor actor.\n\nExamples\n\nusing Rocket\n\nactor = void(Int)\nactor isa VoidActor{Int}\n\n# output\ntrue\n\n\nSee also: VoidActor, AbstractActor\n\n\n\n\n\n","category":"function"},{"location":"actors/types/void/","page":"Void","title":"Void","text":"VoidActor","category":"page"},{"location":"actors/types/void/#Rocket.VoidActor","page":"Void","title":"Rocket.VoidActor","text":"VoidActor{D}() where D\n\nVoid actor does nothing with input data, error and complete events, can be useful for debugging (e.g. to start side-effects with tap operator)\n\nExamples\n\nusing Rocket\n\nsource = from([ 0, 1, 2 ])\nactor  = VoidActor{Int}()\n\nsubscribe!(source, actor)\n;\n\n# output\n\n\nSee also: Actor, void, tap\n\n\n\n\n\n","category":"type"},{"location":"observables/types/proxy/#observable_proxy","page":"Proxy","title":"Proxy Observable","text":"","category":"section"},{"location":"observables/types/proxy/","page":"Proxy","title":"Proxy","text":"ProxyObservable might help to create a custom operator. It wraps either source and/or actor with their proxied versions providing additional custom logic for on_subscribe! and/or for on_next!, on_error!, on_complete! methods.","category":"page"},{"location":"observables/types/proxy/","page":"Proxy","title":"Proxy","text":"proxy\nProxyObservable","category":"page"},{"location":"observables/types/proxy/#Rocket.proxy","page":"Proxy","title":"Rocket.proxy","text":"proxy(::Type{L}, source, proxy) where L\n\nCreation operator for the ProxyObservable with a given source and proxy objects.\n\nExample\n\nusing Rocket\n\nsource = from(1:5)\n\nstruct MyCustomProxy <: ActorProxy end\n\nstruct MyCustomActor{A} <: Actor{Int}\n    actor :: A\nend\n\nRocket.on_next!(actor::MyCustomActor, data::Int) = next!(actor.actor, data ^ 2)\nRocket.on_error!(actor::MyCustomActor, err)      = error!(actor.actor, err)\nRocket.on_complete!(actor::MyCustomActor)        = complete!(actor.actor)\n\nRocket.actor_proxy!(::Type{Int}, proxy::MyCustomProxy, actor::A) where A = MyCustomActor{A}(actor)\n\nproxied = proxy(Int, source, MyCustomProxy())\n\nsubscribe!(proxied, logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 4\n[LogActor] Data: 9\n[LogActor] Data: 16\n[LogActor] Data: 25\n[LogActor] Completed\n\nSee also: ProxyObservable, ActorProxy, SourceProxy, ActorSourceProxy\n\n\n\n\n\n","category":"function"},{"location":"observables/types/proxy/#Rocket.ProxyObservable","page":"Proxy","title":"Rocket.ProxyObservable","text":"ProxyObservable{L, S, P}(proxied_source::S, proxy::P)\n\nAn interface for proxied Observables.\n\nSee also: proxy\n\n\n\n\n\n","category":"type"},{"location":"observables/types/proxy/","page":"Proxy","title":"Proxy","text":"ActorProxy\nSourceProxy\nActorSourceProxy","category":"page"},{"location":"observables/types/proxy/#Rocket.ActorProxy","page":"Proxy","title":"Rocket.ActorProxy","text":"ActorProxy\n\nCan be used as a super type for common proxy object. Automatically specifies ValidActorProxy trait behavior. Each ActorProxy must implement its own method for actor_proxy!(::Type, proxy, actor) function which have to return a valid actor object.\n\nSee also: proxy, actor_proxy!\n\n\n\n\n\n","category":"type"},{"location":"observables/types/proxy/#Rocket.SourceProxy","page":"Proxy","title":"Rocket.SourceProxy","text":"SourceProxy\n\nCan be used as a super type for common proxy object. Automatically specifies ValidSourceProxy trait behavior. Each SourceProxy must implement its own method for source_proxy!(::Type, proxy, source) function which have to return a valid subscribable object.\n\nSee also: proxy, source_proxy!\n\n\n\n\n\n","category":"type"},{"location":"observables/types/proxy/#Rocket.ActorSourceProxy","page":"Proxy","title":"Rocket.ActorSourceProxy","text":"ActorSourceProxy\n\nCan be used as a super type for common proxy object. Automatically specifies ValidActorSourceProxy trait behavior. Each ActorSourceProxy must implement its own method for source_proxy!(::Type, proxy, source) function which have to return a valid subscribable object and also for actor_proxy!(::Type, proxy, actor) function which have to return a valid actor object..\n\nSee also: proxy, actor_proxy!, source_proxy!\n\n\n\n\n\n","category":"type"},{"location":"observables/types/proxy/","page":"Proxy","title":"Proxy","text":"actor_proxy!\nsource_proxy!","category":"page"},{"location":"observables/types/proxy/#Rocket.actor_proxy!","page":"Proxy","title":"Rocket.actor_proxy!","text":"actor_proxy!(::Type, proxy, actor)\n\nThis is function is used to wrap an actor with its proxied version given a particular proxy object. Must return another actor. Each valid ActorProxy and ActorSourceProxy must implement its own method for actor_proxy! function. The first argument is the same as the type of data of the connected proxy observable.\n\nSee also: proxy, ActorProxy, ActorSourceProxy\n\n\n\n\n\n","category":"function"},{"location":"observables/types/proxy/#Rocket.source_proxy!","page":"Proxy","title":"Rocket.source_proxy!","text":"source_proxy!(::Type, proxy, source)\n\nThis is function is used to wrap a source with its proxied version given a particular proxy object. Must return another Observable. Each valid SourceProxy and ActorSourceProxy must implement its own method for source_proxy! function. The first argument is the same as the type of data of the connected proxy observable.\n\nSee also: proxy, SourceProxy, ActorSourceProxy\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/to_array/#operator_to_array","page":"to_array","title":"Uppercase Operator","text":"","category":"section"},{"location":"operators/transformation/to_array/","page":"to_array","title":"to_array","text":"to_array","category":"page"},{"location":"operators/transformation/to_array/#Rocket.to_array","page":"to_array","title":"Rocket.to_array","text":"to_array()\n\nCreates a to_array operator, which reduces all values into a single array and returns this result when the source completes.\n\nProducing\n\nStream of type <: Subscribable{Vector{L}} where L refers to type of source stream\n\nExamples\n\nusing Rocket\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> to_array(), logger())\n;\n\n# output\n\n[LogActor] Data: [1, 2, 3]\n[LogActor] Completed\n\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/to_array/#See-also","page":"to_array","title":"See also","text":"","category":"section"},{"location":"operators/transformation/to_array/","page":"to_array","title":"to_array","text":"Operators, map, lowercase","category":"page"},{"location":"operators/transformation/about/#Transformation-category","page":"About transformation operators","title":"Transformation category","text":"","category":"section"},{"location":"operators/transformation/about/","page":"About transformation operators","title":"About transformation operators","text":"There are operators for different purposes, and they may be categorized as: creation, transformation, filtering, joining, multicasting, error handling, utility, etc. In the following list you will find all the operators organized in transformation category.","category":"page"},{"location":"operators/transformation/about/","page":"About transformation operators","title":"About transformation operators","text":"map\nmap_to\nscan\naccumulated\nenumerate\nuppercase\nlowercase\nto_array\nswitch_map\nswitch_map_to\nmerge_map\nconcat_map\nconcat_map_to\nexhaust_map\nstart_with\npairwise\nsubstitute\noverride","category":"page"},{"location":"operators/transformation/about/#See-also","page":"About transformation operators","title":"See also","text":"","category":"section"},{"location":"operators/transformation/about/","page":"About transformation operators","title":"About transformation operators","text":"Operators","category":"page"}]
}
